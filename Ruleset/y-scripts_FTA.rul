items:
  - type: STR_FLASHBANG_GRENADE
    tags:
      FTAG_DAZE_VALUE: 100 #percentage
      FTAG_DAZE_TIME: 2
  - type: STR_LAUNCHER_FLASHBANG
    tags:
      FTAG_DAZE_VALUE: 100 #percentage
      FTAG_DAZE_TIME: 2

soldierBonuses:
  - name: STR_SNIPER
    tags:
      SNIPER_CRIT_CHANCE: 20    #bonus chance to land a critical hit
      SNIPER_CRIT_VALUE: 150    #bonus % power of critical hit
      AIM: 1                    #(1/0) enables 30% bonus accuracy when kneeling on the position you were kneeling on the start of the turn
      #DEATH_FROM_ABOVE: 10      #bonus % damage when damaging from above

extended:
  tags: # Remember to add tag definitions to same file as item/armor rulesets!
    RuleSoldierBonus:
      SNIPER_CRIT_CHANCE: int
      SNIPER_CRIT_VALUE: int
      AIM: int
    RuleItem:
      PHYSICAL_SHIELD_ARMOR: int
      ITEM_IS_MELEE: int
      ITEM_SHIELD_BLOCK_MELEE_COEFFICIENT: int
      ITEM_SHIELD_BLOCK_REACTIONS_COEFFICIENT: int
      #psi-shield
      ITEM_ENERGY_SHIELD_NEEDS_PRIMING: int
      ITEM_ENERGY_SHIELD_CAPACITY: int
      ITEM_ENERGY_SHIELD_PER_TURN: int
      ITEM_ENERGY_SHIELD_TYPE: int
      ITEM_ENERGY_SHIELD_FLASH_COLOR: int # Color group for flash when unit is hit
      ITEM_ENERGY_SHIELD_INDICATOR_COLOR: int # Color group for item's indicator
      ITEM_ENERGY_SHIELD_COLOR_REPLACED_BY_INDICATOR: int # Color group that is replaced by indicator
      ITEM_ENERGY_SHIELD_DOWN_COLOR: int # Indicator switches to this color group when down
      #flashbang
      FTAG_DAZE_VALUE: int
      FTAG_DAZE_TIME: int
      FTAG_TOPSIKER_ADD_POWER: int
      FTAG_SELFKILL_WEAPON: int #facehugger weapon
    RuleArmor:
      #psi-shield      
      ARMOR_ENERGY_SHIELD_CAPACITY: int
      ARMOR_ENERGY_SHIELD_PER_TURN: int
      ARMOR_ENERGY_SHIELD_TYPE: int
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: int # Color group for flash when unit is hit
    BattleItem:
      ITEM_ENERGY_SHIELD_HP: int
      ITEM_ENERGY_SHIELD_IS_PRIMED: int
    BattleUnit:
      #psi-shield
      UNIT_ENERGY_SHIELD_HP: int
      UNIT_RECOLOR_DESYNC: int
      UNIT_RECOLOR_COLOR: int
      UNIT_RECOLOR_START_FRAME: int
      UNIT_RECOLOR_FRAME_LENGTH: int
      #flashbang
      FTAG_ISDAZED: int
      LAST_HIT_FRAME: int
      FTAG_DAZE_ENDTURN: int
      FTAG_DAZE_ORIGINAL_TIMEUNITS: int
      FTAG_DAZE_ORIGINAL_REACTIONS: int
      FTAG_DAZE_ORIGINAL_FIRING: int
      FTAG_DAZE_ORIGINAL_THROWING: int
      FTAG_DAZE_ORIGINAL_MELEE: int
      #sniper
      AIM_STATE: int
      AIM_X: int
      AIM_Y: int
      AIM_Z: int

  scripts:
    createUnit:
        #*** Sets the frequency and offset for periodic unit recolors for buffs and debuffs ***
      - offset: 1
        code: |
          var int recolorPeriod;
          var int desync;

          set recolorPeriod 32; # units flash every 32 frames
          unit.getId desync;
          offsetmod desync 11 0 recolorPeriod; # creates a desynchronization between unit flashes
          unit.setTag Tag.UNIT_RECOLOR_DESYNC desync;

          return;

      - offset: 2
        code: |
          # Set energy shields on unit armor at beginning of the battle

          var ptr RuleArmor armorRuleset;
          var int shieldCapacity;

          unit.getRuleArmor armorRuleset;
          armorRuleset.getTag shieldCapacity Tag.ARMOR_ENERGY_SHIELD_CAPACITY;

          if eq shieldCapacity 0;
            return;
          end;

          unit.setTag Tag.UNIT_ENERGY_SHIELD_HP shieldCapacity;

          return;

    createItem:
      - offset: 1
        code: |
          # Set energy shields on items at beginning of the battle

          var ptr RuleItem itemRuleset;
          var int shieldCapacity;
          var int temp;

          item.getRuleItem itemRuleset;
          itemRuleset.getTag shieldCapacity Tag.ITEM_ENERGY_SHIELD_CAPACITY;
          itemRuleset.getTag temp Tag.ITEM_ENERGY_SHIELD_NEEDS_PRIMING;

          # Only set shield values at beginning of battlescape for shields that don't need priming
          if and neq shieldCapacity 0 eq temp 0;
            item.setTag Tag.ITEM_ENERGY_SHIELD_HP shieldCapacity;
          end;

          return;

    newTurnUnit:
      - offset: 1   # Define aim initial properties
        code: |
          var int is_kneeling;
          var int pos_x;
          var int pos_y;
          var int pos_z;
          var int aim;
          var int kneeling;
          if eq side 0; # xcom turns
            unit.getTag aim Tag.AIM_STATE;
            unit.isKneeled kneeling;

            if and gt aim 0 gt kneeling 0;
              unit.getPosition.getX pos_x;
              unit.getPosition.getY pos_y;
              unit.getPosition.getZ pos_z;

              unit.setTag Tag.AIM_STATE 2; # was kneeling at the beginning of the turn
              
              unit.setTag Tag.AIM_X pos_x;
              unit.setTag Tag.AIM_Y pos_y;
              unit.setTag Tag.AIM_Z pos_z;
            end;
          end;
          return;

      - offset: 2 # Handle energy shield on armor regeneration/degeneration every turn
        code: |
          var ptr RuleArmor armorRuleset;
          var int shieldCapacity;
          var int shieldPerTurn;
          var int shieldHp;

          # Make sure this doesn't run an extra time when civilians have a turn
          if eq side 2;
            return;
          end;

          unit.getRuleArmor armorRuleset;
          armorRuleset.getTag shieldCapacity Tag.ARMOR_ENERGY_SHIELD_CAPACITY;
          armorRuleset.getTag shieldPerTurn Tag.ARMOR_ENERGY_SHIELD_PER_TURN;

          if eq shieldPerTurn 0;
            return;
          end;

          unit.getTag shieldHp Tag.UNIT_ENERGY_SHIELD_HP;
          add shieldHp shieldPerTurn;
          limit shieldHp 0 shieldCapacity;
          unit.setTag Tag.UNIT_ENERGY_SHIELD_HP shieldHp;

          return;

      - offset: 4 #Flashbang ongoing check script
        code: |
          var int currTurn;
          var int endTurn;
          var int dazeTag;
          var int originalTimeUnits;
          var int originalReactions;
          var int originalFiring;
          var int originalThrowing;
          var int originalMelee;

          # Make sure this doesn't run an extra time when civilians have a turn
          if eq side 2;
            return;
          end;

          unit.getTag dazeTag Tag.FTAG_ISDAZED;
          unit.getTag endTurn Tag.FTAG_DAZE_ENDTURN;
          unit.getTag originalTimeUnits Tag.FTAG_DAZE_ORIGINAL_TIMEUNITS;
          unit.getTag originalReactions Tag.FTAG_DAZE_ORIGINAL_REACTIONS;
          unit.getTag originalFiring Tag.FTAG_DAZE_ORIGINAL_FIRING;
          unit.getTag originalThrowing Tag.FTAG_DAZE_ORIGINAL_THROWING;
          unit.getTag originalMelee Tag.FTAG_DAZE_ORIGINAL_MELEE;

          battle_game.getTurn currTurn;

          if eq dazeTag 69;
            if eq currTurn endTurn;
              unit.Stats.setTimeUnits originalTimeUnits; #revent debuff
              unit.Stats.setReactions originalReactions; 
              unit.Stats.setFiring originalFiring; 
              unit.Stats.setThrowing originalThrowing; 
              unit.Stats.setMelee originalMelee; 
              unit.setTag Tag.FTAG_ISDAZED 0; #cancel tag
              battle_game.flashMessage "STR_TARGET_IS_NOT_DAZED";
            end;
          end;

          return;

    newTurnItem:
      - offset: 2 # Handle energy shield on items regeneration/degeneration every turn
        code: |
          var ptr RuleItem shieldRule;
          var int shieldCapacity;
          var int shieldTimer;
          var int shieldIsPrimed;
          var int shieldPerTurn;
          var int shieldHp;
          var int temp;

          # Make sure this doesn't run an extra time when civilians have a turn
          if eq side 2;
            return;
          end;

          # Recharge/decay handling for shield items
          item.getRuleItem shieldRule;
          shieldRule.getTag shieldCapacity Tag.ITEM_ENERGY_SHIELD_CAPACITY;

          if eq shieldCapacity 0;
            return;
          end;

          # Check if this is prime-able type, handle if it is
          shieldRule.getTag temp Tag.ITEM_ENERGY_SHIELD_NEEDS_PRIMING;

          if neq temp 0;
            item.getFuseTimer shieldTimer;

            if neq shieldTimer -1;
              # Make sure it's primed, if not, do so now
              item.getTag shieldIsPrimed Tag.ITEM_ENERGY_SHIELD_IS_PRIMED;

              if eq shieldIsPrimed 0;
                item.setTag Tag.ITEM_ENERGY_SHIELD_IS_PRIMED 1;
                item.setTag Tag.ITEM_ENERGY_SHIELD_HP shieldCapacity;
              end;

              shieldRule.getTag shieldPerTurn Tag.ITEM_ENERGY_SHIELD_PER_TURN;
              item.getTag shieldHp Tag.ITEM_ENERGY_SHIELD_HP;

              # Recharge/decay shield, respecting capacity and 0
              add shieldHp shieldPerTurn;
              limit shieldHp 0 shieldCapacity;
              item.setTag Tag.ITEM_ENERGY_SHIELD_HP shieldHp;
            end;
          else;
            # Handling here for shields that don't need priming
            shieldRule.getTag shieldPerTurn Tag.ITEM_ENERGY_SHIELD_PER_TURN;
            item.getTag shieldHp Tag.ITEM_ENERGY_SHIELD_HP;

            # Recharge/decay shield, respecting capacity and 0
            add shieldHp shieldPerTurn;
            limit shieldHp 0 shieldCapacity;
            item.setTag Tag.ITEM_ENERGY_SHIELD_HP shieldHp;
          end;

          return;

    hitUnit:
      - offset: 0.1 #Anti-psiker weapon
        code: |
          var ptr RuleItem itemRuleset;
          var int addPower;
          var int psiStrength;

          damaging_item.getRuleItem itemRuleset; #get stats from item
          itemRuleset.getTag addPower Tag.FTAG_TOPSIKER_ADD_POWER;

          if neq addPower 0;
            unit.Stats.getPsiStrength psiStrength;
            mul addPower psiStrength;
            
            div addPower 100;
            #debug_log 2 addPower; #for good
            add power addPower;
          end;

          return power part side;

      - offset: 1 # Handle item energy shields on hit
        code: |
          var ptre BattleItem shieldItem;
          var ptr RuleItem shieldRule;
          var int shieldCapacity;
          var int shieldNeedsPriming;
          var int shieldTimer;
          var int shieldType;
          var int shieldResistCoeff;
          var int shieldHp;
          var int temp;

          # Script to handle item energy shields on hit
          # Check for item in left hand
          unit.getLeftHandWeapon shieldItem;

          if neq shieldItem null;
            # Check to see if the item has a shield capacity tag
            shieldItem.getRuleItem shieldRule;
            shieldRule.getTag shieldCapacity Tag.ITEM_ENERGY_SHIELD_CAPACITY;

            if neq shieldCapacity 0;

              # Check if we need to handle prime-able shields
              shieldItem.getFuseTimer shieldTimer;
              shieldRule.getTag shieldNeedsPriming Tag.ITEM_ENERGY_SHIELD_NEEDS_PRIMING;

              set temp 0; # Ensure this is equal to 0 for the check whether the shield is used to reduce damage

              if and neq shieldTimer -1 neq shieldNeedsPriming 0;
                shieldItem.getTag temp Tag.ITEM_ENERGY_SHIELD_IS_PRIMED;

                if eq temp 0; # If we just primed and haven't been hit yet, need to set shield HP
                  shieldItem.setTag Tag.ITEM_ENERGY_SHIELD_IS_PRIMED 1;
                  shieldItem.setTag Tag.ITEM_ENERGY_SHIELD_HP shieldCapacity;

                  set temp 1; # Tells that shield is primed and ready for use
                end;
              end;

              # If shield doesn't need priming, it's ready to go. Otherwise, make sure temp was set by the priming action
              if or eq shieldNeedsPriming 0 neq temp 0; 

                shieldRule.getTag shieldType Tag.ITEM_ENERGY_SHIELD_TYPE;

                if or eq shieldType 0 eq shieldType 1; # Default and shield type 1
                  # Check which damage type and set shield's 'resistance'
                  # If it's special, choking, heat, or cold, just skip the rest
                  if or eq damaging_type 0 eq damaging_type 9 eq damaging_type 10 eq damaging_type 11;
                    return power part side;

                  # resistances
                  else eq damaging_type 4; # Laser
                    set shieldResistCoeff 35;
                  else eq damaging_type 5; # Plasma
                    set shieldResistCoeff 60;
                  else; # All other damage types
                    set shieldResistCoeff 100;
                  end;

                else eq shieldType 2;
                  if or eq damaging_type 0 eq damaging_type 9 eq damaging_type 10 eq damaging_type 11;
                    return power part side;
                  else eq damaging_type 4; # Laser
                    set shieldResistCoeff 35;
                  else eq damaging_type 5; # Plasma
                    set shieldResistCoeff 60;
                  else; # All other damage types
                    set shieldResistCoeff 100;
                  end;

                else eq shieldType 3;
                  if or eq damaging_type 0 eq damaging_type 8 eq damaging_type 9 eq damaging_type 10 eq damaging_type 11;
                    return power part side;
                  else or eq damaging_type 15 eq damaging_type 16 eq damaging_type 17;
                    return power part side;
                  else eq damaging_type 1; # AP
                    set shieldResistCoeff 75;
                  else eq damaging_type 4; # Laser
                    set shieldResistCoeff 50;
                  else eq damaging_type 5; # Plasma
                    set shieldResistCoeff 50;
                  else eq damaging_type 13; # EMP
                    set shieldResistCoeff 200;
                  else; # All other damage types
                    set shieldResistCoeff 100;
                  end;

                end;

                # Get the item's HP value and reduce damage by it
                shieldItem.getTag shieldHp Tag.ITEM_ENERGY_SHIELD_HP;

                # Modify shield hp value by resistance to get effective HP
                muldiv shieldHp 100 shieldResistCoeff;
                set temp shieldHp;

                sub temp power; # get shield value leftover after hit
                sub power shieldHp; # reduce hit by hp

                # Return shield to pre-resistance units
                muldiv temp shieldResistCoeff 100;

                # Apply limits to make sure no negative power/HP
                limit_lower power 0;
                limit_lower temp 0;

                # Set the shield's new HP value
                shieldItem.setTag Tag.ITEM_ENERGY_SHIELD_HP temp;

                # Make the unit flash a color to denote shield was hit
                if and gt temp 0 eq power 0; # But only if shield is left over
                  battle_game.getAnimFrame temp;
                  unit.setTag Tag.UNIT_RECOLOR_START_FRAME temp;
                  unit.setTag Tag.UNIT_RECOLOR_FRAME_LENGTH 3;

                  shieldRule.getTag temp Tag.ITEM_ENERGY_SHIELD_FLASH_COLOR;
                  if eq temp 0;
                    set temp COLOR_X1_BLUE1; # Default color is bright blue
                  end;
                  unit.setTag Tag.UNIT_RECOLOR_COLOR temp;
                end;
              end;
            end;
          end;

          # Now do it for a right hand shield
          unit.getRightHandWeapon shieldItem;

          if neq shieldItem null;
            # Check to see if the item has a shield capacity tag
            shieldItem.getRuleItem shieldRule;
            shieldRule.getTag shieldCapacity Tag.ITEM_ENERGY_SHIELD_CAPACITY;

            if neq shieldCapacity 0;

              # Check if we need to handle prime-able shields
              shieldItem.getFuseTimer shieldTimer;
              shieldRule.getTag shieldNeedsPriming Tag.ITEM_ENERGY_SHIELD_NEEDS_PRIMING;

              set temp 0; # Ensure this is equal to 0 for the check whether the shield is used to reduce damage

              if and neq shieldTimer -1 neq shieldNeedsPriming 0;
                shieldItem.getTag temp Tag.ITEM_ENERGY_SHIELD_IS_PRIMED;

                if eq temp 0; # If we just primed and haven't been hit yet, need to set shield HP
                  shieldItem.setTag Tag.ITEM_ENERGY_SHIELD_IS_PRIMED 1;
                  shieldItem.setTag Tag.ITEM_ENERGY_SHIELD_HP shieldCapacity;

                  set temp 1; # Tells that shield is primed and ready for use
                end;
              end;

              # If shield doesn't need priming, it's ready to go. Otherwise, make sure temp was set by the priming action
              if or eq shieldNeedsPriming 0 neq temp 0; 

                shieldRule.getTag shieldType Tag.ITEM_ENERGY_SHIELD_TYPE;

                if or eq shieldType 0 eq shieldType 1; # Default and shield type 1
                  # Check which damage type and set shield's 'resistance'
                  # If it's special, choking, heat, or cold, just skip the rest
                  if or eq damaging_type 0 eq damaging_type 9 eq damaging_type 10 eq damaging_type 11;
                    return power part side;

                  # resistances
                  else eq damaging_type 4; # Laser
                    set shieldResistCoeff 35;
                  else eq damaging_type 5; # Plasma
                    set shieldResistCoeff 60;
                  else; # All other damage types
                    set shieldResistCoeff 100;
                  end;

                else eq shieldType 2;
                  if or eq damaging_type 0 eq damaging_type 9 eq damaging_type 10 eq damaging_type 11;
                    return power part side;
                  else eq damaging_type 4; # Laser
                    set shieldResistCoeff 35;
                  else eq damaging_type 5; # Plasma
                    set shieldResistCoeff 60;
                  else; # All other damage types
                    set shieldResistCoeff 100;
                  end;

                else eq shieldType 3;
                  if or eq damaging_type 0 eq damaging_type 8 eq damaging_type 9 eq damaging_type 10 eq damaging_type 11;
                    return power part side;
                  else or eq damaging_type 15 eq damaging_type 16 eq damaging_type 17;
                    return power part side;
                  else eq damaging_type 1; # AP
                    set shieldResistCoeff 75;
                  else eq damaging_type 4; # Laser
                    set shieldResistCoeff 50;
                  else eq damaging_type 5; # Plasma
                    set shieldResistCoeff 50;
                  else eq damaging_type 13; # EMP
                    set shieldResistCoeff 200;
                  else; # All other damage types
                    set shieldResistCoeff 100;
                  end;

                end;

                # Get the item's HP value and reduce damage by it
                shieldItem.getTag shieldHp Tag.ITEM_ENERGY_SHIELD_HP;

                # Modify shield hp value by resistance to get effective HP
                muldiv shieldHp 100 shieldResistCoeff;
                set temp shieldHp;

                sub temp power; # get shield value leftover after hit
                sub power shieldHp; # reduce hit by hp

                # Return shield to pre-resistance units
                muldiv temp shieldResistCoeff 100;

                # Apply limits to make sure no negative power/HP
                limit_lower power 0;
                limit_lower temp 0;

                # Set the shield's new HP value
                shieldItem.setTag Tag.ITEM_ENERGY_SHIELD_HP temp;

                # Make the unit flash a color to denote shield was hit
                if and gt temp 0 eq power 0; # But only if shield is left over
                  battle_game.getAnimFrame temp;
                  unit.setTag Tag.UNIT_RECOLOR_START_FRAME temp;
                  unit.setTag Tag.UNIT_RECOLOR_FRAME_LENGTH 3;

                  shieldRule.getTag temp Tag.ITEM_ENERGY_SHIELD_FLASH_COLOR;
                  if eq temp 0;
                    set temp COLOR_X1_BLUE1; # Default color is bright blue
                  end;
                  unit.setTag Tag.UNIT_RECOLOR_COLOR temp;
                end;
              end;
            end;
          end;

          # return modified power
          return power part side;

      - offset: 2 # Handle energy shields on armor on hit
        code: |
          var ptr RuleArmor armorRuleset;
          var int shieldHp;
          var int shieldType;
          var int shieldResistCoeff;
          var int temp;

          unit.getTag shieldHp Tag.UNIT_ENERGY_SHIELD_HP;

          if eq shieldHp 0;
            return power part side;
          end;

          unit.getRuleArmor armorRuleset;

          armorRuleset.getTag shieldType Tag.ARMOR_ENERGY_SHIELD_TYPE;

          if or eq shieldType 0; # Default; Tzeentch
            # Check which damage type and set shield's 'resistance'
            # If it's special, choking, heat, or cold, just skip the rest
            if or eq damaging_type 0 eq damaging_type 9 eq damaging_type 14;
              return power part side;

            # resistances
            else eq damaging_type 1; # AP
              set shieldResistCoeff 50;
            else eq damaging_type 2; # Incendiary
              set shieldResistCoeff 50;
            else eq damaging_type 3; # Hi-Ex
              set shieldResistCoeff 50;
            else eq damaging_type 5; # Plasma
              set shieldResistCoeff 125;
            else eq damaging_type 6; # Stun
              set shieldResistCoeff 175;
            else eq damaging_type 7; # Melee
              set shieldResistCoeff 125;
            else eq damaging_type 8; # Acid
              set shieldResistCoeff 175;
            else eq damaging_type 11; # Electric
              set shieldResistCoeff 66;
            else eq damaging_type 12; # Psi
              set shieldResistCoeff 33;
            else eq damaging_type 13; # Warp
              set shieldResistCoeff 33;
            else; # All other damage types
              set shieldResistCoeff 100;
            end;

          else eq shieldType 1; # Shield type 1 - Slaanesh
            if or eq damaging_type 0 eq damaging_type 9 eq damaging_type 14;
              return power part side;

            # resistances
            else eq damaging_type 1; # AP
              set shieldResistCoeff 175;
            else eq damaging_type 2; # Incendiary
              set shieldResistCoeff 175;
            else eq damaging_type 3; # Hi-Ex
              set shieldResistCoeff 175;
            else eq damaging_type 4; # Laser
              set shieldResistCoeff 33;
            else eq damaging_type 5; # Plasma
              set shieldResistCoeff 125;
            else eq damaging_type 6; # Stun
              set shieldResistCoeff 50;
            else eq damaging_type 7; # Melee
              set shieldResistCoeff 125;
            else eq damaging_type 8; # Acid
              set shieldResistCoeff 50;
            else eq damaging_type 10; # EMP
              set shieldResistCoeff 66;
            else eq damaging_type 11; # Electric
              set shieldResistCoeff 66;
            else; # All other damage types
              set shieldResistCoeff 100;
            end;

          else eq shieldType 2; # Shield type 2 - Nurgle
            if or eq damaging_type 0 eq damaging_type 9 eq damaging_type 14;
              return power part side;

            # resistances
            else eq damaging_type 4; # Laser
              set shieldResistCoeff 175;
            else eq damaging_type 5; # Plasma
              set shieldResistCoeff 125;
            else eq damaging_type 6; # Stun
              set shieldResistCoeff 33;
            else eq damaging_type 7; # Melee
              set shieldResistCoeff 125;
            else eq damaging_type 8; # Acid
              set shieldResistCoeff 33;
            else eq damaging_type 10; # EMP
              set shieldResistCoeff 33;
            else eq damaging_type 12; # Psi
              set shieldResistCoeff 50;
            else eq damaging_type 13; # Warp
              set shieldResistCoeff 50;
            else; # All other damage types
              set shieldResistCoeff 100;
            end;

          else eq shieldType 3; # Shield type 3 - Khorne
            if or eq damaging_type 0 eq damaging_type 9 eq damaging_type 14;
              return power part side;

            # resistances
            else eq damaging_type 1; # AP
              set shieldResistCoeff 33;
            else eq damaging_type 2; # Incendiary
              set shieldResistCoeff 33;
            else eq damaging_type 3; # Hi-Ex
              set shieldResistCoeff 33;
            else eq damaging_type 4; # Laser
              set shieldResistCoeff 50;
            else eq damaging_type 5; # Plasma
              set shieldResistCoeff 125;
            else eq damaging_type 7; # Melee
              set shieldResistCoeff 125;
            else eq damaging_type 10; # EMP
              set shieldResistCoeff 150;
            else eq damaging_type 12; # Psi
              set shieldResistCoeff 175;
            else eq damaging_type 13; # Warp
              set shieldResistCoeff 175;
            else; # All other damage types
              set shieldResistCoeff 100;
            end;

          end;

          # Get the item's HP value and reduce damage by it
          # Modify shield hp value by resistance to get effective HP
          muldiv shieldHp 100 shieldResistCoeff;
          set temp shieldHp;

          sub temp power; # get shield value leftover after hit
          sub power shieldHp; # reduce hit by hp

          # Return shield to pre-resistance units
          muldiv temp shieldResistCoeff 100;

          # Apply limits to make sure no negative power/HP
          limit_lower power 0;
          limit_lower temp 0;

          unit.setTag Tag.UNIT_ENERGY_SHIELD_HP temp;

          # Make the unit flash a color to denote shield was hit
          if and gt temp 0 eq power 0; # But only if shield is left over
            battle_game.getAnimFrame temp;
            unit.setTag Tag.UNIT_RECOLOR_START_FRAME temp;
            unit.setTag Tag.UNIT_RECOLOR_FRAME_LENGTH 3;

            armorRuleset.getTag temp Tag.ARMOR_ENERGY_SHIELD_FLASH_COLOR;
            if eq temp 0;
              set temp COLOR_X1_BLUE1; # Default color is bright blue
            end;
            unit.setTag Tag.UNIT_RECOLOR_COLOR temp;
          end;

          return power part side;

      - offset: 3 # arm shield thing
        code: |
          var ptr BattleItem shieldItem;
          var ptr RuleItem damagingRuleset;
          var ptr RuleItem shieldRuleset;
          var int shieldArmor;
          var int shieldResistCoeff;
          var int shieldMeleeDodge;
          var int shieldReactionsDodge;
          var int unitMelee;
          var int unitReactions;
          var int temp;

          # Check for shield in left hand first, then right.  If no shield, skip the script
          unit.getLeftHandWeapon shieldItem;
          shieldItem.getRuleItem shieldRuleset;
          shieldRuleset.getTag shieldArmor Tag.PHYSICAL_SHIELD_ARMOR;
          shieldRuleset.getTag shieldMeleeDodge Tag.ITEM_SHIELD_BLOCK_MELEE_COEFFICIENT;
          shieldRuleset.getTag shieldReactionsDodge Tag.ITEM_SHIELD_BLOCK_REACTIONS_COEFFICIENT;

          if eq shieldArmor 0;
            unit.getRightHandWeapon shieldItem;
            shieldItem.getRuleItem shieldRuleset;
            shieldRuleset.getTag shieldArmor Tag.PHYSICAL_SHIELD_ARMOR;
            shieldRuleset.getTag shieldMeleeDodge Tag.ITEM_SHIELD_BLOCK_MELEE_COEFFICIENT;
            shieldRuleset.getTag shieldReactionsDodge Tag.ITEM_SHIELD_BLOCK_REACTIONS_COEFFICIENT;
            if eq shieldArmor 0;
              return power part side;
            end;
          end;

          # Check which damage type and set shield's 'resistance'
          # If it's special, choking, heat, or cold, just skip the rest
          if or eq damaging_type 0 eq damaging_type 9 eq damaging_type 10 eq damaging_type 11;
            return power part side;
          end;

          # Check to see if the shield blocks all damage from a melee hit, like melee dodge
          damaging_item.getRuleItem damagingRuleset;
          damagingRuleset.getTag temp Tag.ITEM_IS_MELEE;
          if or neq 0 temp eq battle_action BA_HIT;
            # Get the stats for melee dodge
            unit.Stats.getMelee unitMelee;
            unit.Stats.getReactions unitReactions;
            muldiv shieldMeleeDodge unitMelee 100;
            muldiv shieldReactionsDodge unitReactions 100;
            add shieldMeleeDodge shieldReactionsDodge;

            # Modify by where the unit was hit
            if or eq side SIDE_LEFT eq side SIDE_RIGHT;
              div shieldMeleeDodge 2;
            else or eq side SIDE_REAR eq side SIDE_UNDER;
              div shieldMeleeDodge 4;
            end;

            battle_game.randomChance temp;
            if lt temp shieldMeleeDodge;
              set power 0;
              return power part side;
            end;
          end;
  
          # Default resistances for all physical shields
          if eq damaging_type 3; # Concussive
            set shieldResistCoeff 90;
          else eq damaging_type 6; # Daze
            set shieldResistCoeff 80;
          else eq damaging_type 7; # Cutting
            set shieldResistCoeff 90;
          else eq damaging_type 7; # Chem
            set shieldResistCoeff 90;
          else; # All other damage types
            set shieldResistCoeff 100;
          end;

          # Calculate the shield's effectiveness and subtract it from the damage
          muldiv shieldArmor 100 shieldResistCoeff;

          if or eq side SIDE_LEFT eq side SIDE_RIGHT;
            div shieldArmor 2;
          else eq side SIDE_UNDER;
            div shieldArmor 4;
          else eq side SIDE_REAR;
            set shieldArmor 0;
          end;

          sub power shieldArmor;
          limit_lower power 0;

          return power part side;


    damageUnit:
      # - offset: 1 #test category script
      #   code: |
      #     var ptr RuleItem itemRuleset;
      #     var ptre GeoscapeGame geoGame;
      #     var int check;
          

      #     #damaging_item.getRuleItem itemRuleset; 
      #     #battle_game.getGeoscapeGame geoGame;
      #     #geoGame.getLoyalty check;
      #     # itemRuleset.getHaveCategory check "STR_SNIPER_RIFLES";
      #     # if eq check 1;
      #     #debug_log "loyalty: " check;
      #     #end;

      #     return;

      - offset: 1 #Flashbang damage script
        code: |
          var ptr RuleItem itemRuleset;
          var ptr RuleArmor armor_rule;
          var int dazeTag;
          var int animFrame;
          var int susceptibility;
          var int applyChance;
          var int dazeValue;
          var int statValue;
          var int debuffValue;
          var int dazeTime;
          var int endTurn;

          damaging_item.getRuleItem itemRuleset; #get debuff stats from item
          itemRuleset.getTag dazeValue Tag.FTAG_DAZE_VALUE;
          itemRuleset.getTag dazeTime Tag.FTAG_DAZE_TIME;
          if eq dazeValue 0; # Make sure item has daze effect
            return;
          end;          

          unit.getTag dazeTag Tag.FTAG_ISDAZED;
          if eq dazeTag 69; # Make sure unit already have daze debuff
            return;
          end;

          # unit.getRuleArmor armor_rule;
          # armor_rule.getTag susceptibility Tag.FTAG_FLASHBANG_RESISTANCE;
          # battle_game.randomRange applyChance 1 100; #calculate random chance for debuff apply
          # if gt susceptibility applyChance; # check if target resist daze
          #   return;
          # end;

          set dazeTag 69; #set dazed tag
          unit.setTag Tag.FTAG_ISDAZED dazeTag;
          battle_game.flashMessage "STR_TARGET_IS_DAZED";
          battle_game.getAnimFrame animFrame;
          unit.setTag Tag.LAST_HIT_FRAME animFrame;

            unit.Stats.getTimeUnits statValue; #remember original TimeUnits stat
            unit.setTag Tag.FTAG_DAZE_ORIGINAL_TIMEUNITS statValue;
            div statValue 2; #calculate TimeUnits debuff, dividing it by 2
            unit.Stats.setTimeUnits statValue; #apply debuff

            unit.getTimeUnits statValue; #also divide actual TUs by 3
            div statValue 3;
            unit.setTimeUnits statValue;

            unit.Stats.getReactions statValue; #remember original Reactions stat
            unit.setTag Tag.FTAG_DAZE_ORIGINAL_REACTIONS statValue;
            battle_game.randomRange debuffValue 25 35; #calculate random, 25-35 for Reactions
            muldiv debuffValue dazeValue 100; #calculate debuff
            sub statValue debuffValue;
            unit.Stats.setReactions statValue; #apply Reactions  debuff

            unit.Stats.getFiring statValue; #remember original Firing stat
            unit.setTag Tag.FTAG_DAZE_ORIGINAL_FIRING statValue;
            battle_game.randomRange debuffValue 20 30; #calculate random, 20-30 for Firing
            muldiv debuffValue dazeValue 100; #calculate debuff
            sub statValue debuffValue;
            unit.Stats.setFiring statValue; #apply debuff

            unit.Stats.getThrowing statValue; #remember original Throwing stat
            unit.setTag Tag.FTAG_DAZE_ORIGINAL_THROWING statValue;
            battle_game.randomRange debuffValue 20 30; #calculate random, 20-30 for Throwing
            muldiv debuffValue dazeValue 100; #calculate debuff
            sub statValue debuffValue;
            unit.Stats.setThrowing statValue; #apply debuff

            unit.Stats.getMelee statValue; #remember original Melee stat
            unit.setTag Tag.FTAG_DAZE_ORIGINAL_MELEE statValue;
            battle_game.randomRange debuffValue 10 20; #calculate random, 10-20 for Melee
            muldiv debuffValue dazeValue 100;
            sub statValue debuffValue;
            unit.Stats.setMelee statValue; #apply debuff

            battle_game.getTurn endTurn;
            add endTurn dazeTime; #define end turn for debuff
            unit.setTag Tag.FTAG_DAZE_ENDTURN endTurn;

          return;

      - offset: 2 #facehugger weapon
        code: |
          var ptre BattleUnit attackingUnit;
          var ptr RuleItem itemRuleset;
          var int check;

          damaging_item.getRuleItem itemRuleset;
          itemRuleset.getTag check Tag.FTAG_SELFKILL_WEAPON;
          if eq check 1;
            attacker.setHealth 0;
          end;
          return;

    # Global fix to Transformation attacks like Chryssalid zombification
    # Requires at least 1 hit point of damage before zombification triggers
    # This applies to *every* weapon that zombifies.  It *has* to get through armor to work.
      - offset: 4
        code: |
          if gt to_transform 0;
            if eq to_health 0;
              set to_transform 0;
            end;
          end;
          return;

    recolorUnitSprite:
      - offset: 0.1 #Handles periodic recolors due to daze
        code: |
          var int frame;
          var int frameLength;
          var int dazeTag;
          var int recolorPeriod;
          var int desync;
          var int color;
          var int newShade;
          var int temp;
          var ptr RuleArmor armorRuleset;

          # Check to make sure this unit isn't set to be recolored by a hit first
          unit.getTag frame Tag.LAST_HIT_FRAME;
          set frameLength 6;
          set recolorPeriod 36;
 
          if neq frame 0;
            set temp anim_frame;
            sub temp frame;

            if lt temp frameLength;
              return new_pixel;
            end;

          end;

          unit.getTag desync Tag.UNIT_RECOLOR_DESYNC;
          set frame anim_frame;
          add frame desync;
          mod frame recolorPeriod;

          unit.getTag temp Tag.FTAG_ISDAZED;

          if and neq temp 0 lt frame frameLength;
            #set temp anim_frame;
            wavegen_tri frame 12 12 12;
            mul frame -1;
            add frame 6; #8;
            get_shade newShade new_pixel;
            sub newShade frame;

            if gt newShade 4;
              set_shade new_pixel newShade;
              else;
              set_shade new_pixel 4;
            end;


          end;

          return new_pixel;

      #*** Handles periodic recolors due to energy shields on units ***
      - offset: 1
        code: |
          var int frame;
          var int frameLength;
          var int recolorPeriod;
          var int desync;
          var int color;
          var int newShade;
          var int temp;
          var ptr RuleArmor armorRuleset;

          # Check to make sure this unit isn't set to be recolored by a hit first
          unit.getTag frame Tag.UNIT_RECOLOR_START_FRAME;
          unit.getTag frameLength Tag.UNIT_RECOLOR_FRAME_LENGTH;

          if neq frame 0;

            set temp anim_frame;
            sub temp frame;

            if lt temp frameLength;

              return new_pixel;

            end;

          end;

          set recolorPeriod 32;
          set frameLength 4;

          unit.getTag desync Tag.UNIT_RECOLOR_DESYNC;
          set frame anim_frame;
          add frame desync;
          mod frame recolorPeriod;

          # First, a blue flash if the unit has an energy shield
          unit.getTag temp Tag.UNIT_ENERGY_SHIELD_HP;

          if and neq temp 0 lt frame frameLength;

            unit.getRuleArmor armorRuleset;
            armorRuleset.getTag color Tag.ARMOR_ENERGY_SHIELD_FLASH_COLOR;

            if eq color 0;

              set color COLOR_X1_BLUE1;

            end;

            set temp frameLength;
            sub temp frame;
            mul temp 2; # a parameter that creates a nice flash animation
            get_shade newShade new_pixel;
            sub newShade temp;

            if and gt newShade 3 lt newShade 16;

              set_shade new_pixel newShade;
              set_color new_pixel color;

            end;

          end;

          return new_pixel;

      - offset: 10
        code: |
          var int frame;
          var int frameLength;
          var int color;
          var int newShade;
          var int temp;

          unit.getTag frame Tag.UNIT_RECOLOR_START_FRAME;
          unit.getTag frameLength Tag.UNIT_RECOLOR_FRAME_LENGTH;

          if neq frame 0;
            set temp anim_frame;
            sub temp frame;

            if lt temp frameLength;
              # Check shade, add some darkening decay, but don't recolor if it'd go too dark
              get_shade newShade new_pixel;
              mul temp 4;
              sub newShade temp;
              if or lt newShade 4 gt newShade 15;
                return new_pixel;
              end;

              unit.getTag color Tag.UNIT_RECOLOR_COLOR;
              set_color new_pixel color;
              set_shade new_pixel newShade;
            end;
          end;

          return new_pixel;

    recolorItemSprite:
      - offset: 10
        code: |
          var ptr RuleItem shieldItem;
          var int shieldCapacity;
          var int shieldNeedsPriming;
          var int shieldTimer;
          var int shieldHp;
          var int shieldPercent;
          var int shieldIsPrimed;
          var int color;
          var int colorToReplace;
          var int shadeIndex;
          var int temp;

          item.getRuleItem shieldItem;
          shieldItem.getTag shieldCapacity Tag.ITEM_ENERGY_SHIELD_CAPACITY;

          if eq shieldCapacity 0;
            return new_pixel;
          end;

          item.getTag shieldHp Tag.ITEM_ENERGY_SHIELD_HP;
          set shieldPercent shieldHp;
          muldiv shieldPercent 100 shieldCapacity;

          # Recolor behavior is based on shield type
          shieldItem.getTag shieldNeedsPriming Tag.ITEM_ENERGY_SHIELD_NEEDS_PRIMING;

          item.getFuseTimer shieldTimer;
          if and neq shieldNeedsPriming 0 gt shieldTimer 0; # Get shield percent for consumable shields
            item.getTag shieldIsPrimed Tag.ITEM_ENERGY_SHIELD_IS_PRIMED;

            if eq shieldIsPrimed 0; # Haven't been hit yet, but should show shield
              set shieldPercent 100;
            end;
          end;

          # Choose color to replace on sprite
          get_color color new_pixel;
          set temp 0;

          # Pick the color to replace from the ruleset tags
          shieldItem.getTag colorToReplace Tag.ITEM_ENERGY_SHIELD_COLOR_REPLACED_BY_INDICATOR;

          if eq color colorToReplace;
            get_shade shadeIndex new_pixel;

            shieldItem.getTag temp Tag.ITEM_ENERGY_SHIELD_INDICATOR_COLOR;

            if eq shieldPercent 0; # Choose critical shields at 20%, make tag later?
              if and neq shieldNeedsPriming 0 gt shieldTimer 0;
                shieldItem.getTag temp Tag.ITEM_ENERGY_SHIELD_DOWN_COLOR;
              else eq shieldNeedsPriming 0;
                shieldItem.getTag temp Tag.ITEM_ENERGY_SHIELD_DOWN_COLOR;
              end;
            end;

            if eq temp 0; # Default color to blue if none is found
              set temp COLOR_X1_BLUE1;
            end;

            set color temp;

            set temp shieldPercent;
            sub temp 100;
            abs temp;
            muldiv temp 15 100;
            add shadeIndex temp;
            limit shadeIndex 0 15;
            set_color new_pixel color;
            set_shade new_pixel shadeIndex;
          end;

          return new_pixel;        

