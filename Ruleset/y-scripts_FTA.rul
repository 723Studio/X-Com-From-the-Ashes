extended:
  tags: # Remember to add tag definitions to same file as item/armor rulesets!
    RuleSoldierBonus:
      CENTER_MASS: int
      AIM: int
      SHREDDER: int
      STEADY_GRIP: int
      BULKY: int
      DEATH_FROM_ABOVE: int
      EVER_VIGILANT: int
      RAPID_TARGETING: int
      REAPER: int
      DASH: int
      UNIFIGHT: int
      FIELD_SURGEON: int
      SAVIOR: int
      UTILITY_SPECIALIST: int
      STR_UNARMED_FIGHTER: int
    RuleItem: # Remember to add tag definitions to same file as item/armor rulesets!
      PHYSICAL_SHIELD_ARMOR: int
      ITEM_IS_MELEE: int
      ITEM_SHIELD_BLOCK_MELEE_COEFFICIENT: int
      ITEM_SHIELD_BLOCK_REACTIONS_COEFFICIENT: int
      #psi-shield
      ITEM_ENERGY_SHIELD_NEEDS_PRIMING: int
      ITEM_ENERGY_SHIELD_CAPACITY: int
      ITEM_ENERGY_SHIELD_PER_TURN: int
      ITEM_ENERGY_SHIELD_TYPE: int
      ITEM_ENERGY_SHIELD_FLASH_COLOR: int # Color group for flash when unit is hit
      ITEM_ENERGY_SHIELD_INDICATOR_COLOR: int # Color group for item's indicator
      ITEM_ENERGY_SHIELD_COLOR_REPLACED_BY_INDICATOR: int # Color group that is replaced by indicator
      ITEM_ENERGY_SHIELD_DOWN_COLOR: int # Indicator switches to this color group when down
      #flashbang
      FTAG_DAZE_VALUE: int
      FTAG_DAZE_TIME: int
      FTAG_TOPSIKER_ADD_POWER: int
      FTAG_SELFKILL_WEAPON: int #facehugger weapon
      FTAG_EXPANDING: int
      FTAG_SAWED_OFF: int
      BPL_AIMED_1_5X_POWER: int
    RuleArmor: # Remember to add tag definitions to same file as item/armor rulesets!
      #psi shield (mana-dependent mechanic)
      ARMOR_PSI_SHIELD_TYPE: int #0 - default, no shield, 1 - usual psi shield
      #energy shield (own hp pool)  
      ARMOR_ENERGY_SHIELD_CAPACITY: int
      ARMOR_ENERGY_SHIELD_PER_TURN: int
      ARMOR_ENERGY_SHIELD_TYPE: int
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: int # Color group for flash when unit is hit
      FTAG_STUN_TO_HP: int #converts stun to hp damage, devide stun damage to 3
    RuleUfo:
      UFO_DETECTION_CHANGE: int
    BattleItem:
      ITEM_ENERGY_SHIELD_HP: int
      ITEM_ENERGY_SHIELD_IS_PRIMED: int
    BattleUnit:
      #psi-shield
      UNIT_PSI_SHIELD_TYPE: int
      #energy shield
      UNIT_ENERGY_SHIELD_HP: int
      UNIT_RECOLOR_DESYNC: int
      UNIT_RECOLOR_COLOR: int
      UNIT_RECOLOR_START_FRAME: int
      UNIT_RECOLOR_FRAME_LENGTH: int
      #flashbang
      FTAG_ISDAZED: int
      LAST_HIT_FRAME: int
      FTAG_DAZE_ENDTURN: int
      FTAG_DAZE_ORIGINAL_TIMEUNITS: int
      FTAG_DAZE_ORIGINAL_REACTIONS: int
      FTAG_DAZE_ORIGINAL_FIRING: int
      FTAG_DAZE_ORIGINAL_THROWING: int
      FTAG_DAZE_ORIGINAL_MELEE: int
      #sniper
      AIM_STATE: int
      AIM_X: int
      AIM_Y: int
      AIM_Z: int
      CENTER_MASS_STATE: int
      DEATH_FROM_ABOVE_STATE: int # 0 - nothing special, 1 - unit has this perk, 2 - unit activate the perk
      DEATH_FROM_ABOVE_HIT_STATE: int # 0 - nothing special, 1 - unit is under death from above reaction suppressing effect
      DEATH_FROM_ABOVE_UNIT_ID: int # ID of a unit that land DfA hit with damage
      #heavy
      SHREDDER_STATE: int
      STEADY_GRIP_STATE: int
      BULKY_STATE: int
      #assault
      EVER_VIGILANT_STATE: int # 0 - nothing special, 1 - unit has this perk, 2 - unit activate additional bonus
      RAPID_TARGETING_STATE: int
      #ranger
      REAPER_STATE: int
      DASH_STATE: int
      UNIFIGHT_STATE: int
      #specialist
      FIELD_SURGEON_STATE: int
      HEALED_BY_FIELD_SURGEON: int
      SAVIOR_STATE: int
      UTILITY_SPECIALIST_STATE: int
      #unarmed
      STR_UNARMED_FIGHTER_STATE: int

  scripts:
    createUnit: 
      - offset: 1     # Sets the frequency and offset for periodic unit recolors for buffs and debuffs
        code: |
          var int recolorPeriod;
          var int desync;

          set recolorPeriod 32; # units flash every 32 frames
          unit.getId desync;
          offsetmod desync 11 0 recolorPeriod; # creates a desynchronization between unit flashes
          unit.setTag Tag.UNIT_RECOLOR_DESYNC desync;

          return;

      - offset: 2     # Set energy shields on unit armor at beginning of the battle
        code: |
          var ptr RuleArmor armorRuleset;
          var int shieldCapacity;

          unit.getRuleArmor armorRuleset;
          armorRuleset.getTag shieldCapacity Tag.ARMOR_ENERGY_SHIELD_CAPACITY;

          if eq shieldCapacity 0;
            return;
          end;

          unit.setTag Tag.UNIT_ENERGY_SHIELD_HP shieldCapacity;

          return;
      
      - offset: 2.1   # Set psi shields as battle unit tag at beginning of the battle
        code: |
          var ptr RuleArmor armorRuleset;
          var int shieldType;
          var int color;

          unit.getRuleArmor armorRuleset;
          armorRuleset.getTag shieldType Tag.ARMOR_PSI_SHIELD_TYPE;

          if eq shieldType 0;
            return;
          end;

          unit.setTag Tag.UNIT_PSI_SHIELD_TYPE shieldType;

          if eq shieldType 1;
            set color COLOR_X1_PURPLE1; #value 12
          else eq shieldType 2;
            set color COLOR_X1_PURPLE0; #value 11
          end;

          if eq color 0;
            set color COLOR_X1_BLUE1; # Default color is bright blue
          end;
          unit.setTag Tag.UNIT_RECOLOR_COLOR color;

          debug_log "Psionic shield is activated for unit, with type: " unit shieldType;

          return;

      - offset: 3     # Lower enemy unit TUs
        code: |
          var int unitTUs;
          var int divisor;
          var int difficulty;
          var int lower;
          var int upper;
          var int faction;

          unit.getFaction faction;
          if eq faction 0; #don't affect XCOM
            return;
          end;

          battle_game.difficultyLevel difficulty;
          if eq difficulty 0; #DIFF_BEGINNER
            set lower 25;
            set upper 50;
          end;
          if eq difficulty 1; #DIFF_EXPERIENCED
            set lower 33;
            set upper 66;
          end;
          if eq difficulty 2; #DIFF_VETERAN
            set lower 40;
            set upper 85;
          end;
          if eq difficulty 3; #DIFF_GENIUS
            set lower 80;
            set upper 100;
          end;
          if eq difficulty 4; #DIFF_SUPERHUMAN
            return; # }:>
          end;
          
          unit.getTimeUnits unitTUs;
          battle_game.randomRange divisor lower upper;
          muldiv unitTUs divisor 100;
          unit.setTimeUnits unitTUs;
          return;

    createItem:
      - offset: 1     # Set energy shields on items at beginning of the battle
        code: |
          var ptr RuleItem itemRuleset;
          var int shieldCapacity;
          var int temp;

          item.getRuleItem itemRuleset;
          itemRuleset.getTag shieldCapacity Tag.ITEM_ENERGY_SHIELD_CAPACITY;
          itemRuleset.getTag temp Tag.ITEM_ENERGY_SHIELD_NEEDS_PRIMING;

          # Only set shield values at beginning of battlescape for shields that don't need priming
          if and neq shieldCapacity 0 eq temp 0;
            item.setTag Tag.ITEM_ENERGY_SHIELD_HP shieldCapacity;
          end;

          return;

    newTurnUnit:
      - offset: 2     # Handle energy shield on armor regeneration/degeneration every turn
        code: |
          var ptr RuleArmor armorRuleset;
          var int shieldCapacity;
          var int shieldPerTurn;
          var int shieldHp;

          # Make sure this doesn't run an extra time when civilians have a turn
          if eq side 2;
            return;
          end;

          unit.getRuleArmor armorRuleset;
          armorRuleset.getTag shieldCapacity Tag.ARMOR_ENERGY_SHIELD_CAPACITY;
          armorRuleset.getTag shieldPerTurn Tag.ARMOR_ENERGY_SHIELD_PER_TURN;

          if eq shieldPerTurn 0;
            return;
          end;

          unit.getTag shieldHp Tag.UNIT_ENERGY_SHIELD_HP;
          add shieldHp shieldPerTurn;
          limit shieldHp 0 shieldCapacity;
          unit.setTag Tag.UNIT_ENERGY_SHIELD_HP shieldHp;

          return;
          # psi shields regeneration handled with mana engine code =)

      - offset: 4     # Handle flashbang ongoing check script
        code: |
          var int currTurn;
          var int endTurn;
          var int dazeTag;
          var int originalTimeUnits;
          var int originalReactions;
          var int originalFiring;
          var int originalThrowing;
          var int originalMelee;

          # Make sure this doesn't run an extra time when civilians have a turn
          if eq side 2;
            return;
          end;

          unit.getTag dazeTag Tag.FTAG_ISDAZED;
          unit.getTag endTurn Tag.FTAG_DAZE_ENDTURN;
          unit.getTag originalTimeUnits Tag.FTAG_DAZE_ORIGINAL_TIMEUNITS;
          unit.getTag originalReactions Tag.FTAG_DAZE_ORIGINAL_REACTIONS;
          unit.getTag originalFiring Tag.FTAG_DAZE_ORIGINAL_FIRING;
          unit.getTag originalThrowing Tag.FTAG_DAZE_ORIGINAL_THROWING;
          unit.getTag originalMelee Tag.FTAG_DAZE_ORIGINAL_MELEE;

          battle_game.getTurn currTurn;

          if eq dazeTag 69;
            if eq currTurn endTurn;
              unit.Stats.setTimeUnits originalTimeUnits; #revert debuff
              unit.Stats.setReactions originalReactions; 
              unit.Stats.setFiring originalFiring; 
              unit.Stats.setThrowing originalThrowing; 
              unit.Stats.setMelee originalMelee; 
              unit.setTag Tag.FTAG_ISDAZED 0; #cancel tag
              battle_game.flashMessage "STR_TARGET_IS_NOT_DAZED";
            end;
          end;

          return;

      - offset: 20   # Define aim initial properties
        code: |
          var int is_kneeling;
          var int pos_x;
          var int pos_y;
          var int pos_z;
          var int aim;
          var int kneeling;
          if eq side 0; # xcom turns
            unit.getTag aim Tag.AIM_STATE;
            unit.isKneeled kneeling;

            if and gt aim 0 gt kneeling 0;
              unit.getPosition.getX pos_x;
              unit.getPosition.getY pos_y;
              unit.getPosition.getZ pos_z;

              unit.setTag Tag.AIM_STATE 2; # was kneeling at the beginning of the turn
              debug_log "AIM_STATE 2 !";
              
              unit.setTag Tag.AIM_X pos_x;
              unit.setTag Tag.AIM_Y pos_y;
              unit.setTag Tag.AIM_Z pos_z;
            end;
          end;
          return;

      - offset: 30   # Handle death from above tags reset
        code: |
          var int deathFromAbove;
          var int deathFromAboveHit;
          
          if eq side 0; # xcom turns
            unit.getTag deathFromAbove Tag.DEATH_FROM_ABOVE_STATE;
            if eq deathFromAbove 2; # we want to clear the state
              unit.setTag Tag.DEATH_FROM_ABOVE_STATE 1;
              debug_log unit " - Death from above reset.";
            end;
          end;

          #just in case remove suppress tag too
          unit.getTag deathFromAboveHit Tag.DEATH_FROM_ABOVE_HIT_STATE;
          if eq deathFromAboveHit 1;
            unit.setTag Tag.DEATH_FROM_ABOVE_HIT_STATE 0;
            unit.setTag Tag.DEATH_FROM_ABOVE_UNIT_ID 0;
            debug_log unit " - Death from above reaction suppress effect reset on new turn!";
          end;

          return;

      - offset: 32   # Handle ever vigilant main effect
        code: |
          var int vigilant;
          var int tu_max;
          var int tu;
          var int roll;
          var int bonus;

          unit.getTag vigilant Tag.EVER_VIGILANT_STATE;
          if eq vigilant 2; #unit have extra vigilance
            unit.setTag Tag.EVER_VIGILANT_STATE 1; #reset back to normal state
          end;

          if and eq side 1 eq vigilant 1; # ever vigilant only triggers on enemy turns
            battle_game.randomRange roll 20 35;
            unit.getTimeUnits tu;
            unit.getTimeUnitsMax tu_max;
            set bonus tu_max;
            muldiv bonus roll 100;
            debug_log unit " - Ever vigilant activated. roll, current TU, max, bonus: " roll tu tu_max bonus;
            add tu bonus;
            unit.setTimeUnits tu;
            if gt tu tu_max;
              # we have extra bonus
              unit.setTag Tag.EVER_VIGILANT_STATE 2;
            end;
          end;

          return;

    newTurnItem:
      - offset: 2     # Handle energy shield on items regeneration/degeneration every turn
        code: |
          var ptr RuleItem shieldRule;
          var int shieldCapacity;
          var int shieldTimer;
          var int shieldIsPrimed;
          var int shieldPerTurn;
          var int shieldHp;
          var int temp;

          # Make sure this doesn't run an extra time when civilians have a turn
          if eq side 2;
            return;
          end;

          # Recharge/decay handling for shield items
          item.getRuleItem shieldRule;
          shieldRule.getTag shieldCapacity Tag.ITEM_ENERGY_SHIELD_CAPACITY;

          if eq shieldCapacity 0;
            return;
          end;

          # Check if this is prime-able type, handle if it is
          shieldRule.getTag temp Tag.ITEM_ENERGY_SHIELD_NEEDS_PRIMING;

          if neq temp 0;
            item.getFuseTimer shieldTimer;

            if neq shieldTimer -1;
              # Make sure it's primed, if not, do so now
              item.getTag shieldIsPrimed Tag.ITEM_ENERGY_SHIELD_IS_PRIMED;

              if eq shieldIsPrimed 0;
                item.setTag Tag.ITEM_ENERGY_SHIELD_IS_PRIMED 1;
                item.setTag Tag.ITEM_ENERGY_SHIELD_HP shieldCapacity;
              end;

              shieldRule.getTag shieldPerTurn Tag.ITEM_ENERGY_SHIELD_PER_TURN;
              item.getTag shieldHp Tag.ITEM_ENERGY_SHIELD_HP;

              # Recharge/decay shield, respecting capacity and 0
              add shieldHp shieldPerTurn;
              limit shieldHp 0 shieldCapacity;
              item.setTag Tag.ITEM_ENERGY_SHIELD_HP shieldHp;
            end;
          else;
            # Handling here for shields that don't need priming
            shieldRule.getTag shieldPerTurn Tag.ITEM_ENERGY_SHIELD_PER_TURN;
            item.getTag shieldHp Tag.ITEM_ENERGY_SHIELD_HP;

            # Recharge/decay shield, respecting capacity and 0
            add shieldHp shieldPerTurn;
            limit shieldHp 0 shieldCapacity;
            item.setTag Tag.ITEM_ENERGY_SHIELD_HP shieldHp;
          end;

          return;

    accuracyMultiplierBonusStats:
      - offset: 10    # Handle sniper aim main effect
        code: |
          var ptr RuleItem itemRuleset;
          var int catCheck;
          var int pos_x;
          var int pos_y;
          var int pos_z;
          var int aim_x;
          var int aim_y;
          var int aim_z;
          var int aim;
          var int kneeling;

          unit.getTag aim Tag.AIM_STATE;

          if eq aim 2; # was aiming at the beginning of the turn
          unit.isKneeled kneeling; # check pos and kneeling
            if gt kneeling 0;
              if eq battle_action 9; #aim shots only
                weapon.getRuleItem itemRuleset;
                itemRuleset.hasCategory catCheck "STR_SNIPER_RIFLES";
                if eq catCheck 1;
                  unit.getPosition.getX pos_x;
                  unit.getPosition.getY pos_y;
                  unit.getPosition.getZ pos_z;

                  unit.getTag aim_x Tag.AIM_X;
                  unit.getTag aim_y Tag.AIM_Y;
                  unit.getTag aim_z Tag.AIM_Z;

                  if and eq pos_x aim_x eq pos_y aim_y eq pos_z aim_z;
                    add bonus 20;
                  end;
                end;
              end;
            end;
          end;

          return bonus;

      - offset: 12    # Handle utility specialist firing (with flashbang) effect
        code: |
          var ptr RuleItem itemRuleset;
          var int catCheck;
          var int stateBonus;
          var int temp;

          unit.getTag stateBonus Tag.UTILITY_SPECIALIST_STATE;

          if gt stateBonus 0;
            weapon.getRuleItem itemRuleset;
            itemRuleset.hasCategory catCheck "STR_UTILITY";
            if eq catCheck 1;
              debug_log "Activating perk UTILITY_SPECIALIST_STATE, initial stat: " bonus;
              set temp 20;
              add bonus temp; #TODO balance it!
              debug_log "UTILITY_SPECIALIST_STATE activated, new stat: " bonus;
              debug_log "Script effect should be balanced, now it's value is: " temp;
            end;
          end;

          return bonus;

      - offset: 15    # Handle steady grip main effect
        code: |
          var ptr RuleItem itemRuleset;
          var int catCheck;
          var int stateBonus;

          unit.getTag stateBonus Tag.STEADY_GRIP_STATE;

          if gt stateBonus 0; # was aiming at the beginning of the turn
            weapon.getRuleItem itemRuleset;
            itemRuleset.hasCategory catCheck "STR_HEAVY_WEAPONS";
            if eq catCheck 1;
              debug_log "Activating perk STEADY_GRIP_STATE, initial stat: " bonus;
              add bonus stateBonus;
              debug_log "STEADY_GRIP_STATE activated, new stat: " bonus;
            end;
          end;

          return bonus;

      - offset: 20    # Handle ever vigilance extra effect
        code: |
          var int state;

          unit.getTag state Tag.EVER_VIGILANT_STATE;

          if eq state 2; # unit has extra vigilance effect
            debug_log "Activating perk EVER_VIGILANT_STATE, initial stat: " bonus;
            add bonus 15;
            debug_log "EVER_VIGILANT_STATE activated, new stat: " bonus;
          end;

          return bonus;

      - offset: 22    # Handle unifight main effect
        code: |
          var int state;

          unit.getTag state Tag.UNIFIGHT_STATE;

          if eq state 2;
            debug_log "Activating perk UNIFIGHT_STATE, initial stat: " bonus;
            add bonus state;
            debug_log "UNIFIGHT_STATE activated, new stat: " bonus;
          end;

          return bonus;

      - offset: 25    # Handle rapid targeting main effect
        code: |
          var ptr RuleItem itemRuleset;
          var int pistolCat;
          var int smgCat;
          var int rifleCat;
          var int shotgunCat;
          var int lmgCat;
          var int catCheck;
          var int stateBonus;

          unit.getTag stateBonus Tag.RAPID_TARGETING_STATE;

          if gt stateBonus 0; # was aiming at the beginning of the turn
            if or eq battle_action 7 eq battle_action 8; #only auto and snap shots
              weapon.getRuleItem itemRuleset;
              itemRuleset.hasCategory pistolCat "STR_PISTOLS";
              itemRuleset.hasCategory smgCat "STR_SMGS";
              itemRuleset.hasCategory rifleCat "STR_RIFLES";
              itemRuleset.hasCategory shotgunCat "STR_SHOTGUNS";
              itemRuleset.hasCategory lmgCat "STR_MACHINE_GUNS";
              if or gt pistolCat 0 gt smgCat 0 gt rifleCat 0 gt shotgunCat 0 gt lmgCat 0;
                set catCheck 1;
              end;

              if eq catCheck 1;
                debug_log "Activating perk RAPID_TARGETING_STATE, initial stat: " bonus;
                add bonus stateBonus;
                debug_log "RAPID_TARGETING_STATE activated, new stat: " bonus;
              end;
            end;
          end;

          return bonus;

      - offset: 30    # Handle expanding ammo accuracy additional logic
        code: |
          var int weaponState;
          var int clipState;

          weapon.getTag weaponState Tag.FTAG_EXPANDING;
          ammo.getTag clipState Tag.FTAG_EXPANDING;

          if lt weaponState clipState;
            sub bonus 10; #our weapon cant handle expanding clips!
          end;

          return bonus;

    throwMultiplierBonusStats:
      - offset: 10    # Handle utility specialist throwing effect
        code: |
          var ptr RuleItem itemRuleset;
          var int catCheck;
          var int stateBonus;
          var int temp;

          unit.getTag stateBonus Tag.UTILITY_SPECIALIST_STATE;

          if gt stateBonus 0;
            weapon.getRuleItem itemRuleset;
            itemRuleset.hasCategory catCheck "STR_UTILITY";
            if eq catCheck 1;
              debug_log "Activating perk UTILITY_SPECIALIST_STATE, initial stat: " bonus;
              set temp 60;
              add bonus temp; #TODO balance it!
              debug_log "UTILITY_SPECIALIST_STATE activated, new stat: " bonus;
              debug_log "Script effect should be balanced, now it's value is: " temp;
            end;
          end;

          return bonus;

      - offset: 15    # Handle throwing penalty for explosive charges
        code: |
          var ptr RuleItem itemRuleset;
          var int catCheck;
          var int stateBonus;
          var int temp;

          weapon.getRuleItem itemRuleset;
          itemRuleset.hasCategory catCheck "STR_EXPLOSIVE_CHARGES";

          if eq catCheck 1;
            debug_log "Activating STR_EXPLOSIVE_CHARGES category penalty, initial stat: " bonus;
            set temp 60;
            sub bonus temp; #TODO balance it!
            debug_log "STR_EXPLOSIVE_CHARGES category penalty activated, new stat: " bonus;
            debug_log "Script effect should be balanced, now it's value is: " temp;
          end;

          return bonus;

    meleeBonusBonusStats:
      - offset: 10    # Unarmed combat #TODO - Fix me pls!
        code: |
          var ptr RuleItem itemRuleset;
          var int catCheck;
          var int stateBonus;
          var int temp;

          unit.getTag stateBonus Tag.STR_UNARMED_FIGHTER_STATE;

          if gt stateBonus 0;
            debug_log "STR_UNARMED_FIGHTER_STATE";
            weapon.getRuleItem itemRuleset;
            itemRuleset.hasCategory catCheck "STR_UNARMED";
            if eq catCheck 1;
              debug_log "Activating perk UNARMED_FIGHTER, bonus value: " bonus;
              add bonus stateBonus;
              debug_log "UTILITY_SPECIALIST_STATE activated, new stat: " bonus;
            end;
          end;

          return bonus;

    hitUnit:
      - offset: 5
        code: |
          var int temp;
          if eq battle_action battle_action_aimshoot;
            weapon_item.getTag temp Tag.BPL_AIMED_1_5X_POWER;
            if neq temp 0;
              set temp power;
              div temp 2;
              add power temp;
            end;
          end;
          return power part side;

      - offset: 10    # Anti-psiker weapon
        code: |
          var ptr RuleItem itemRuleset;
          var int addPower;
          var int psiStrength;

          weapon_item.getRuleItem itemRuleset; #get stats from item
          itemRuleset.getTag addPower Tag.FTAG_TOPSIKER_ADD_POWER;

          if neq addPower 0;
            unit.Stats.getPsiStrength psiStrength;
            mul addPower psiStrength;
            
            div addPower 100;
            add power addPower;
          end;

          return power part side;

      - offset: 10    # Sawed-off power nerf
        code: |
          var ptr RuleItem itemRuleset;
          var int coeff;

          weapon_item.getRuleItem itemRuleset; #get stats from item
          itemRuleset.getTag coeff Tag.FTAG_SAWED_OFF;
          debug_log "coeff: " coeff;
          debug_log "weapon_item: " weapon_item;

          if neq coeff 0;
            debug_log "Ops, its Sawed-Off, power drop from: " power;
            muldiv power coeff 100;
            debug_log "New power value: " power;
          end;

          return power part side;

      - offset: 19   # for critical strike (center mass effect)
        code: |
          var int critChance;
          var int critValue;
          var int critSource; # 1 - Center mass, 
          var int roll;
          var int centerMass;
          var int catCheck;
          var int gun_type;
          var ptr RuleItem itemRuleset;

          attacker.getTag centerMass Tag.CENTER_MASS_STATE;

          set critChance centerMass; #FIXME for now, we have only one crit chance source.
          set critSource 1; 

          if gt critChance 0;
            battle_game.randomRange roll 1 100; # roll for crit
            if gt critChance roll; 
              
              weapon_item.getRuleItem itemRuleset;
              if eq critSource 1; # we have sniper's Center Mass crit
                itemRuleset.hasCategory catCheck "STR_RIFLES";
                if gt catCheck 0;
                  set critValue 120;
                end;
                itemRuleset.hasCategory catCheck "STR_SNIPER_RIFLES";
                if gt catCheck 0;
                  set critValue 150;
                end;
              end;
              if gt critValue 0;
                debug_log "Critical hit rolled! Original power: " power;
                muldiv power critValue 100;
                debug_log " - power increased to: " power;
              end;
            end;
          end;
          return power part side;

      - offset: 20    # Handle item energy shields on hit
        code: |
          var ptre BattleItem shieldItem;
          var ptr RuleItem shieldRule;
          var int shieldCapacity;
          var int shieldNeedsPriming;
          var int shieldTimer;
          var int shieldType;
          var int shieldResistCoeff;
          var int shieldHp;
          var int temp;

          # Script to handle item energy shields on hit
          # Check for item in left hand
          unit.getLeftHandWeapon shieldItem;

          if neq shieldItem null;
            # Check to see if the item has a shield capacity tag
            shieldItem.getRuleItem shieldRule;
            shieldRule.getTag shieldCapacity Tag.ITEM_ENERGY_SHIELD_CAPACITY;

            if neq shieldCapacity 0;

              # Check if we need to handle prime-able shields
              shieldItem.getFuseTimer shieldTimer;
              shieldRule.getTag shieldNeedsPriming Tag.ITEM_ENERGY_SHIELD_NEEDS_PRIMING;

              set temp 0; # Ensure this is equal to 0 for the check whether the shield is used to reduce damage

              if and neq shieldTimer -1 neq shieldNeedsPriming 0;
                shieldItem.getTag temp Tag.ITEM_ENERGY_SHIELD_IS_PRIMED;

                if eq temp 0; # If we just primed and haven't been hit yet, need to set shield HP
                  shieldItem.setTag Tag.ITEM_ENERGY_SHIELD_IS_PRIMED 1;
                  shieldItem.setTag Tag.ITEM_ENERGY_SHIELD_HP shieldCapacity;

                  set temp 1; # Tells that shield is primed and ready for use
                end;
              end;

              # If shield doesn't need priming, it's ready to go. Otherwise, make sure temp was set by the priming action
              if or eq shieldNeedsPriming 0 neq temp 0; 

                shieldRule.getTag shieldType Tag.ITEM_ENERGY_SHIELD_TYPE;

                if or eq shieldType 0 eq shieldType 1; # Default and shield type 1
                  # Check which damage type and set shield's 'resistance'
                  # If it's special, choking, heat, or cold, just skip the rest
                  if or eq damaging_type 0 eq damaging_type 9 eq damaging_type 10 eq damaging_type 11;
                    return power part side;

                  # resistances
                  else eq damaging_type 4; # Laser
                    set shieldResistCoeff 35;
                  else eq damaging_type 5; # Plasma
                    set shieldResistCoeff 60;
                  else; # All other damage types
                    set shieldResistCoeff 100;
                  end;

                else eq shieldType 2;
                  if or eq damaging_type 0 eq damaging_type 9 eq damaging_type 10 eq damaging_type 11;
                    return power part side;
                  else eq damaging_type 4; # Laser
                    set shieldResistCoeff 35;
                  else eq damaging_type 5; # Plasma
                    set shieldResistCoeff 60;
                  else; # All other damage types
                    set shieldResistCoeff 100;
                  end;

                else eq shieldType 3;
                  if or eq damaging_type 0 eq damaging_type 8 eq damaging_type 9 eq damaging_type 10 eq damaging_type 11;
                    return power part side;
                  else or eq damaging_type 15 eq damaging_type 16 eq damaging_type 17;
                    return power part side;
                  else eq damaging_type 1; # AP
                    set shieldResistCoeff 75;
                  else eq damaging_type 4; # Laser
                    set shieldResistCoeff 50;
                  else eq damaging_type 5; # Plasma
                    set shieldResistCoeff 50;
                  else eq damaging_type 13; # EMP
                    set shieldResistCoeff 200;
                  else; # All other damage types
                    set shieldResistCoeff 100;
                  end;

                end;

                # Get the item's HP value and reduce damage by it
                shieldItem.getTag shieldHp Tag.ITEM_ENERGY_SHIELD_HP;

                # Modify shield hp value by resistance to get effective HP
                muldiv shieldHp 100 shieldResistCoeff;
                set temp shieldHp;

                sub temp power; # get shield value leftover after hit
                sub power shieldHp; # reduce hit by hp

                # Return shield to pre-resistance units
                muldiv temp shieldResistCoeff 100;

                # Apply limits to make sure no negative power/HP
                limit_lower power 0;
                limit_lower temp 0;

                # Set the shield's new HP value
                shieldItem.setTag Tag.ITEM_ENERGY_SHIELD_HP temp;

                # Make the unit flash a color to denote shield was hit
                if and gt temp 0 eq power 0; # But only if shield is left over
                  battle_game.getAnimFrame temp;
                  unit.setTag Tag.UNIT_RECOLOR_START_FRAME temp;
                  unit.setTag Tag.UNIT_RECOLOR_FRAME_LENGTH 3;

                  shieldRule.getTag temp Tag.ITEM_ENERGY_SHIELD_FLASH_COLOR;
                  if eq temp 0;
                    set temp COLOR_X1_BLUE1; # Default color is bright blue
                  end;
                  unit.setTag Tag.UNIT_RECOLOR_COLOR temp;
                end;
              end;
            end;
          end;

          # Now do it for a right hand shield
          unit.getRightHandWeapon shieldItem;

          if neq shieldItem null;
            # Check to see if the item has a shield capacity tag
            shieldItem.getRuleItem shieldRule;
            shieldRule.getTag shieldCapacity Tag.ITEM_ENERGY_SHIELD_CAPACITY;

            if neq shieldCapacity 0;

              # Check if we need to handle prime-able shields
              shieldItem.getFuseTimer shieldTimer;
              shieldRule.getTag shieldNeedsPriming Tag.ITEM_ENERGY_SHIELD_NEEDS_PRIMING;

              set temp 0; # Ensure this is equal to 0 for the check whether the shield is used to reduce damage

              if and neq shieldTimer -1 neq shieldNeedsPriming 0;
                shieldItem.getTag temp Tag.ITEM_ENERGY_SHIELD_IS_PRIMED;

                if eq temp 0; # If we just primed and haven't been hit yet, need to set shield HP
                  shieldItem.setTag Tag.ITEM_ENERGY_SHIELD_IS_PRIMED 1;
                  shieldItem.setTag Tag.ITEM_ENERGY_SHIELD_HP shieldCapacity;

                  set temp 1; # Tells that shield is primed and ready for use
                end;
              end;

              # If shield doesn't need priming, it's ready to go. Otherwise, make sure temp was set by the priming action
              if or eq shieldNeedsPriming 0 neq temp 0; 

                shieldRule.getTag shieldType Tag.ITEM_ENERGY_SHIELD_TYPE;

                if or eq shieldType 0 eq shieldType 1; # Default and shield type 1
                  # Check which damage type and set shield's 'resistance'
                  # If it's special, choking, heat, or cold, just skip the rest
                  if or eq damaging_type 0 eq damaging_type 9 eq damaging_type 10 eq damaging_type 11;
                    return power part side;

                  # resistances
                  else eq damaging_type 4; # Laser
                    set shieldResistCoeff 35;
                  else eq damaging_type 5; # Plasma
                    set shieldResistCoeff 60;
                  else; # All other damage types
                    set shieldResistCoeff 100;
                  end;

                else eq shieldType 2;
                  if or eq damaging_type 0 eq damaging_type 9 eq damaging_type 10 eq damaging_type 11;
                    return power part side;
                  else eq damaging_type 4; # Laser
                    set shieldResistCoeff 35;
                  else eq damaging_type 5; # Plasma
                    set shieldResistCoeff 60;
                  else; # All other damage types
                    set shieldResistCoeff 100;
                  end;

                else eq shieldType 3;
                  if or eq damaging_type 0 eq damaging_type 8 eq damaging_type 9 eq damaging_type 10 eq damaging_type 11;
                    return power part side;
                  else or eq damaging_type 15 eq damaging_type 16 eq damaging_type 17;
                    return power part side;
                  else eq damaging_type 1; # AP
                    set shieldResistCoeff 75;
                  else eq damaging_type 4; # Laser
                    set shieldResistCoeff 50;
                  else eq damaging_type 5; # Plasma
                    set shieldResistCoeff 50;
                  else eq damaging_type 13; # EMP
                    set shieldResistCoeff 200;
                  else; # All other damage types
                    set shieldResistCoeff 100;
                  end;

                end;

                # Get the item's HP value and reduce damage by it
                shieldItem.getTag shieldHp Tag.ITEM_ENERGY_SHIELD_HP;

                # Modify shield hp value by resistance to get effective HP
                muldiv shieldHp 100 shieldResistCoeff;
                set temp shieldHp;

                sub temp power; # get shield value leftover after hit
                sub power shieldHp; # reduce hit by hp

                # Return shield to pre-resistance units
                muldiv temp shieldResistCoeff 100;

                # Apply limits to make sure no negative power/HP
                limit_lower power 0;
                limit_lower temp 0;

                # Set the shield's new HP value
                shieldItem.setTag Tag.ITEM_ENERGY_SHIELD_HP temp;

                # Make the unit flash a color to denote shield was hit
                if and gt temp 0 eq power 0; # But only if shield is left over
                  battle_game.getAnimFrame temp;
                  unit.setTag Tag.UNIT_RECOLOR_START_FRAME temp;
                  unit.setTag Tag.UNIT_RECOLOR_FRAME_LENGTH 3;

                  shieldRule.getTag temp Tag.ITEM_ENERGY_SHIELD_FLASH_COLOR;
                  if eq temp 0;
                    set temp COLOR_X1_BLUE1; # Default color is bright blue
                  end;
                  unit.setTag Tag.UNIT_RECOLOR_COLOR temp;
                end;
              end;
            end;
          end;

          # return modified power
          return power part side;

      - offset: 22    # Handle energy shields on armor on hit
        code: |
          var ptr RuleArmor armorRuleset;
          var int shieldHp;
          var int shieldType;
          var int shieldResistCoeff;
          var int temp;

          unit.getTag shieldHp Tag.UNIT_ENERGY_SHIELD_HP;

          if eq shieldHp 0;
            return power part side;
          end;

          unit.getRuleArmor armorRuleset;

          armorRuleset.getTag shieldType Tag.ARMOR_ENERGY_SHIELD_TYPE;

          if or eq shieldType 0; # Default;
            # Check which damage type and set shield's 'resistance'
            # If it's special, choking, heat, or cold, just skip the rest
            if or eq damaging_type 0 eq damaging_type 9 eq damaging_type 14;
              return power part side;

            # resistances
            else eq damaging_type 1; # AP
              set shieldResistCoeff 150; #was 50
            else eq damaging_type 2; # Incendiary
              set shieldResistCoeff 120; #was 50
            else eq damaging_type 3; # Hi-Ex
              set shieldResistCoeff 130; #was 50
            else eq damaging_type 5; # Plasma
              set shieldResistCoeff 125;
            else eq damaging_type 6; # Stun
              set shieldResistCoeff 175;
            else eq damaging_type 7; # Melee
              set shieldResistCoeff 125;
            else eq damaging_type 8; # Acid
              set shieldResistCoeff 175;
            else eq damaging_type 11; # Electric
              set shieldResistCoeff 75; #was 66
            else eq damaging_type 12; # Psi
              set shieldResistCoeff 33;
            else eq damaging_type 13; # Warp
              set shieldResistCoeff 33;
            else; # All other damage types
              set shieldResistCoeff 100;
            end;

          else eq shieldType 1; # Shield type 1 - Slaanesh
            if or eq damaging_type 0 eq damaging_type 9 eq damaging_type 14;
              return power part side;

            # resistances
            else eq damaging_type 1; # AP
              set shieldResistCoeff 175;
            else eq damaging_type 2; # Incendiary
              set shieldResistCoeff 175;
            else eq damaging_type 3; # Hi-Ex
              set shieldResistCoeff 175;
            else eq damaging_type 4; # Laser
              set shieldResistCoeff 33;
            else eq damaging_type 5; # Plasma
              set shieldResistCoeff 125;
            else eq damaging_type 6; # Stun
              set shieldResistCoeff 50;
            else eq damaging_type 7; # Melee
              set shieldResistCoeff 125;
            else eq damaging_type 8; # Acid
              set shieldResistCoeff 50;
            else eq damaging_type 10; # EMP
              set shieldResistCoeff 66;
            else eq damaging_type 11; # Electric
              set shieldResistCoeff 66;
            else; # All other damage types
              set shieldResistCoeff 100;
            end;

          else eq shieldType 2; # Shield type 2 - Nurgle
            if or eq damaging_type 0 eq damaging_type 9 eq damaging_type 14;
              return power part side;

            # resistances
            else eq damaging_type 4; # Laser
              set shieldResistCoeff 175;
            else eq damaging_type 5; # Plasma
              set shieldResistCoeff 125;
            else eq damaging_type 6; # Stun
              set shieldResistCoeff 33;
            else eq damaging_type 7; # Melee
              set shieldResistCoeff 125;
            else eq damaging_type 8; # Acid
              set shieldResistCoeff 33;
            else eq damaging_type 10; # EMP
              set shieldResistCoeff 33;
            else eq damaging_type 12; # Psi
              set shieldResistCoeff 50;
            else eq damaging_type 13; # Warp
              set shieldResistCoeff 50;
            else; # All other damage types
              set shieldResistCoeff 100;
            end;

          else eq shieldType 3; # Shield type 3 - Khorne
            if or eq damaging_type 0 eq damaging_type 9 eq damaging_type 14;
              return power part side;

            # resistances
            else eq damaging_type 1; # AP
              set shieldResistCoeff 33;
            else eq damaging_type 2; # Incendiary
              set shieldResistCoeff 33;
            else eq damaging_type 3; # Hi-Ex
              set shieldResistCoeff 33;
            else eq damaging_type 4; # Laser
              set shieldResistCoeff 50;
            else eq damaging_type 5; # Plasma
              set shieldResistCoeff 125;
            else eq damaging_type 7; # Melee
              set shieldResistCoeff 125;
            else eq damaging_type 10; # EMP
              set shieldResistCoeff 150;
            else eq damaging_type 12; # Psi
              set shieldResistCoeff 175;
            else eq damaging_type 13; # Warp
              set shieldResistCoeff 175;
            else; # All other damage types
              set shieldResistCoeff 100;
            end;

          end;

          # Get the item's HP value and reduce damage by it
          # Modify shield hp value by resistance to get effective HP
          muldiv shieldHp 100 shieldResistCoeff;
          set temp shieldHp;

          sub temp power; # get shield value leftover after hit
          sub power shieldHp; # reduce hit by hp

          # Return shield to pre-resistance units
          muldiv temp shieldResistCoeff 100;

          # Apply limits to make sure no negative power/HP
          limit_lower power 0;
          limit_lower temp 0;

          unit.setTag Tag.UNIT_ENERGY_SHIELD_HP temp;

          # Make the unit flash a color to denote shield was hit
          if and gt temp 0 eq power 0; # But only if shield is left over
            battle_game.getAnimFrame temp;
            unit.setTag Tag.UNIT_RECOLOR_START_FRAME temp;
            unit.setTag Tag.UNIT_RECOLOR_FRAME_LENGTH 3;

            armorRuleset.getTag temp Tag.ARMOR_ENERGY_SHIELD_FLASH_COLOR;
            if eq temp 0;
              set temp COLOR_X1_BLUE1; # Default color is bright blue
            end;
            unit.setTag Tag.UNIT_RECOLOR_COLOR temp;
          end;

          return power part side;

      - offset: 22    # Handle psi shields hit event
        code: |
          var ptr RuleArmor armorRuleset;
          var int mana;
          var int shieldType;
          var int shieldResistCoeff;
          var int color;
          var int temp;

          unit.getTag shieldType Tag.UNIT_PSI_SHIELD_TYPE;

          if eq shieldType 0;
            return power part side;
          end;

          unit.getMana mana;

          if eq mana 0;
            return power part side;
          end;

          debug_log "We hit psionic shield with type, unit's mana, original power: " shieldType mana power;

          unit.getRuleArmor armorRuleset;

          if or eq shieldType 1; # Default psionic type, purple
            # Check which damage type and set shield's 'resistance'
            # If it's special, choking, warp, pressure or bio just skip the rest
            if or eq damaging_type 0 eq damaging_type 9 eq damaging_type 13 eq damaging_type 14 eq damaging_type 15;
              return power part side;

            # resistances
            else eq damaging_type 1; # AP
              set shieldResistCoeff 50;
            else eq damaging_type 2; # Incendiary
              set shieldResistCoeff 50;
            else eq damaging_type 3; # Hi-Ex
              set shieldResistCoeff 60;
            else eq damaging_type 5; # Laser
              set shieldResistCoeff 125;
            else eq damaging_type 5; # Plasma
              set shieldResistCoeff 150;
            else eq damaging_type 6; # Stun
              set shieldResistCoeff 50;
            else eq damaging_type 7; # Melee
              set shieldResistCoeff 85;
            else eq damaging_type 8; # Acid
              set shieldResistCoeff 175;
            else eq damaging_type 11; # Electric
              set shieldResistCoeff 100;
            else eq damaging_type 12; # Psi
              set shieldResistCoeff 300;
            else; # All other damage types
              set shieldResistCoeff 100;
            end;

          else eq shieldType 2; # Extra shield type, for future use
            if or eq damaging_type 0 eq damaging_type 9 eq damaging_type 14;
              return power part side;

            # resistances
            else eq damaging_type 1; # AP
              set shieldResistCoeff 175;
            else eq damaging_type 2; # Incendiary
              set shieldResistCoeff 175;
            else eq damaging_type 3; # Hi-Ex
              set shieldResistCoeff 175;
            else eq damaging_type 4; # Laser
              set shieldResistCoeff 33;
            else eq damaging_type 5; # Plasma
              set shieldResistCoeff 125;
            else eq damaging_type 6; # Stun
              set shieldResistCoeff 50;
            else eq damaging_type 7; # Melee
              set shieldResistCoeff 125;
            else eq damaging_type 8; # Acid
              set shieldResistCoeff 50;
            else eq damaging_type 10; # EMP
              set shieldResistCoeff 66;
            else eq damaging_type 11; # Electric
              set shieldResistCoeff 66;
            else; # All other damage types
              set shieldResistCoeff 100;
            end;

          end;

          # Get the item's HP value and reduce damage by it
          # Modify shield hp value by resistance to get effective HP
          debug_log "shieldResistCoeff: " shieldResistCoeff;
          muldiv mana 100 shieldResistCoeff;
          set temp mana;

          debug_log "Effective mana: " temp;

          sub temp power; # get shield value leftover after hit
          sub power mana; # reduce hit by hp

          # Return shield to pre-resistance units
          muldiv temp shieldResistCoeff 100;

          # Apply limits to make sure no negative power/HP
          limit_lower power 0;
          limit_lower temp 0;

          unit.setMana temp;

          debug_log "Power reduced to: " power;
          debug_log "Unit's mana now: " temp;

          # Make the unit flash a color to denote shield was hit
          if and gt temp 0 eq power 0; # But only if shield is left over
            battle_game.getAnimFrame temp;
            unit.setTag Tag.UNIT_RECOLOR_START_FRAME temp;
            unit.setTag Tag.UNIT_RECOLOR_FRAME_LENGTH 3;
          end;

          return power part side;

      - offset: 23    # Physical arm shield thing
        code: |
          var ptre BattleItem shieldItem;
          var ptr RuleItem damagingRuleset;
          var ptr RuleItem shieldRuleset;
          var ptr RuleDamageType ruleDamage;
          var int catCheck;
          var int hp;
          var int shieldArmor;
          var int shieldResistCoeff;
          var int toArmor;
          var int toItem;
          var int armorEffect;
          var int toArmorPre;
          var int unitMelee;
          var int unitReactions;
          var int attackerMelee;
          var int attackerReactions;
          var int temp;

          # Check for shield in left hand first, then right.  If no shield, skip the script
          unit.getLeftHandWeapon shieldItem;
          shieldItem.getRuleItem shieldRuleset;
          shieldRuleset.hasCategory catCheck "STR_SHIELDS";

          if eq catCheck 0;
            return power part side;
          end;

          # Check which damage type and set shield's 'resistance'
          #Skip shield code for special, choke (smoke), EMP, Electric, Psi, Warp, 
          if or eq damaging_type 0 eq damaging_type 6 eq damaging_type 9 eq damaging_type 10 eq damaging_type 11; 
            if or eq damaging_type 12 eq damaging_type 13 eq damaging_type 14 eq damaging_type 15;
              return power part side;
            end;
          end;

          if neq side 0;
            return power part side;
          end;

          shieldItem.getAmmoQuantity hp;
          if le hp 1;
            return power part side;
          end;

          # Default resistances for all physical shields
          if eq damaging_type 3; # Explosive
            set shieldResistCoeff 90;
          else eq damaging_type 7; # Cutting
            set shieldResistCoeff 85;
          else eq damaging_type 8; # Acid
            set shieldResistCoeff 120;
          else; # All other damage types
            set shieldResistCoeff 100;
          end;

          set shieldArmor hp; 
      
          damaging_item.getRuleItem damagingRuleset;
          damagingRuleset.getDamageType ruleDamage;
          ruleDamage.getDamageToArmor toArmor power;
          ruleDamage.getDamageToItem toItem power;
          ruleDamage.getDamageToArmorPre toArmorPre power;
          ruleDamage.getArmorEffectiveness armorEffect;
          add toArmor toItem;

          # let's subtract pure damage from power, we will add it in the end
          sub power toArmorPre;

          # Calculate the shield's effectiveness and subtract it from the damage
          if gt armorEffect 0;
            add shieldResistCoeff armorEffect;
            sub shieldResistCoeff 100;
          end;
          muldiv shieldArmor shieldResistCoeff 100;

          # Calculate resulting power reduction
          if gt shieldArmor power;
            set shieldArmor power;
          end;
          
          sub power shieldArmor;

          #Calculate damage to the shield
          add shieldArmor toArmor;
          sub hp shieldArmor;
          shieldItem.setAmmoQuantity hp;
          # Don't forget to add ToArmorPre in the end!
          add power toArmorPre;

          return power part side;

      - offset: 38    # Handle aim reset
        code: |
          var int aim;
          attacker.getTag aim Tag.AIM_STATE;

          if eq aim 2; # was aiming
            unit.setTag Tag.AIM_STATE 1;  # reset aim bonus after first hit
            debug_log "Aim bonus reset!";
          end;
          return power part side;

    damageUnit:
      - offset: 1     # Flashbang damage script
        code: |
          var ptr RuleItem itemRuleset;
          var ptr RuleArmor armor_rule;
          var int dazeTag;
          var int animFrame;
          var int susceptibility;
          var int applyChance;
          var int dazeValue;
          var int statValue;
          var int debuffValue;
          var int dazeTime;
          var int endTurn;

          damaging_item.getRuleItem itemRuleset; #get debuff stats from item
          itemRuleset.getTag dazeValue Tag.FTAG_DAZE_VALUE;
          itemRuleset.getTag dazeTime Tag.FTAG_DAZE_TIME;
          if eq dazeValue 0; # Make sure item has daze effect
            return;
          end;          

          unit.getTag dazeTag Tag.FTAG_ISDAZED;
          if eq dazeTag 69; # Make sure unit already have daze debuff
            return;
          end;

          # unit.getRuleArmor armor_rule;
          # armor_rule.getTag susceptibility Tag.FTAG_FLASHBANG_RESISTANCE;
          # battle_game.randomRange applyChance 1 100; #calculate random chance for debuff apply
          # if gt susceptibility applyChance; # check if target resist daze
          #   return;
          # end;

          set dazeTag 69; #set dazed tag
          unit.setTag Tag.FTAG_ISDAZED dazeTag;
          battle_game.flashMessage "STR_TARGET_IS_DAZED";
          battle_game.getAnimFrame animFrame;
          unit.setTag Tag.LAST_HIT_FRAME animFrame;

            unit.Stats.getTimeUnits statValue; #remember original TimeUnits stat
            unit.setTag Tag.FTAG_DAZE_ORIGINAL_TIMEUNITS statValue;
            div statValue 2; #calculate TimeUnits debuff, dividing it by 2
            unit.Stats.setTimeUnits statValue; #apply debuff

            unit.getTimeUnits statValue; #also divide actual TUs by 3
            div statValue 3;
            unit.setTimeUnits statValue;

            unit.Stats.getReactions statValue; #remember original Reactions stat
            unit.setTag Tag.FTAG_DAZE_ORIGINAL_REACTIONS statValue;
            battle_game.randomRange debuffValue 25 35; #calculate random, 25-35 for Reactions
            muldiv debuffValue dazeValue 100; #calculate debuff
            sub statValue debuffValue;
            unit.Stats.setReactions statValue; #apply Reactions  debuff

            unit.Stats.getFiring statValue; #remember original Firing stat
            unit.setTag Tag.FTAG_DAZE_ORIGINAL_FIRING statValue;
            battle_game.randomRange debuffValue 20 30; #calculate random, 20-30 for Firing
            muldiv debuffValue dazeValue 100; #calculate debuff
            sub statValue debuffValue;
            unit.Stats.setFiring statValue; #apply debuff

            unit.Stats.getThrowing statValue; #remember original Throwing stat
            unit.setTag Tag.FTAG_DAZE_ORIGINAL_THROWING statValue;
            battle_game.randomRange debuffValue 20 30; #calculate random, 20-30 for Throwing
            muldiv debuffValue dazeValue 100; #calculate debuff
            sub statValue debuffValue;
            unit.Stats.setThrowing statValue; #apply debuff

            unit.Stats.getMelee statValue; #remember original Melee stat
            unit.setTag Tag.FTAG_DAZE_ORIGINAL_MELEE statValue;
            battle_game.randomRange debuffValue 10 20; #calculate random, 10-20 for Melee
            muldiv debuffValue dazeValue 100;
            sub statValue debuffValue;
            unit.Stats.setMelee statValue; #apply debuff

            battle_game.getTurn endTurn;
            add endTurn dazeTime; #define end turn for debuff
            unit.setTag Tag.FTAG_DAZE_ENDTURN endTurn;

          return;

      - offset: 2     # facehugger weapon
        code: |
          var ptre BattleUnit attackingUnit;
          var ptr RuleItem itemRuleset;
          var int check;

          damaging_item.getRuleItem itemRuleset;
          itemRuleset.getTag check Tag.FTAG_SELFKILL_WEAPON;
          if eq check 1;
            attacker.setHealth 0;
          end;

          return;

      - offset: 4     # Global fix to Transformation attacks like Chryssalid zombification
        code: |
          if gt to_transform 0;
            if eq to_health 0;
              set to_transform 0;
            end;
          end;
          return;

      - offset: 5   # Handle extra hp damage from stun
        code: |
          var ptr RuleArmor armor_rule;
          var int stunVul;

          unit.getRuleArmor armor_rule;
          armor_rule.getTag stunVul Tag.FTAG_STUN_TO_HP;

          if gt stunVul 0;
            set to_health to_stun;
            div to_stun 3;
          end;

          return;

      - offset: 25   # Handle death from above debuff apply
        code: |
          var ptr RuleItem itemRuleset;
          var int catCheck;
          var int attacker_height_level;
          var int victim_height_level;
          var int has_death_from_above;
          var int attackerId;
          var int moraleDamage;

          attacker.getTag has_death_from_above Tag.DEATH_FROM_ABOVE_STATE;

          if gt has_death_from_above 0;
            attacker.getPosition.getZ attacker_height_level;
            unit.getPosition.getZ victim_height_level;
            if gt attacker_height_level victim_height_level;
              weapon_item.getRuleItem itemRuleset;
              itemRuleset.hasCategory catCheck "STR_SNIPER_RIFLES";
              if eq battle_action battle_action_aimshoot; # must be aim attack
                unit.setTag Tag.DEATH_FROM_ABOVE_HIT_STATE 1;  # apply reaction suppressor effect
                attacker.setTag Tag.DEATH_FROM_ABOVE_STATE 2;  # apply perk active state
                attacker.getId attackerId;
                unit.setTag Tag.DEATH_FROM_ABOVE_UNIT_ID attackerId;  # remember who hit us
                debug_log "Death from above effect applied, unit / attacherId: " unit attackerId;
                set moraleDamage currPower;
                div moraleDamage 2;
                add to_morale moraleDamage;
                debug_log "Additional moral damage: " to_morale;
              end;
            end;
          end;

          return;

      - offset: 27   # Handle Reaper mechanic
        code: |
          var ptr RuleItem itemRuleset;
          var int unit_health;
          var int unit_half_max_health;
          var int has_reaper;
          var int addTu;
          var int attackerTu;
          var int critChance;
          var int bonusToHealth;
          var int bonusToStun;
          var int power;
          var int catCheck;
          var int slain;
          var int roll;
          var int stun;


          attacker.getTag has_reaper Tag.REAPER_STATE;

          if eq has_reaper 1; # attacker has reaper perk
            
            if eq battle_action battle_action_hit; # must be melee attack
              weapon_item.getRuleItem itemRuleset;
              itemRuleset.hasCategory catCheck "STR_MELEE";
              if eq catCheck 1;
                unit.getHealth unit_health;
                unit.getHealthMax unit_half_max_health;
                div unit_half_max_health 2;
                set critChance 4; #reaper has 4% crit by default with melee

                #handle reaper crit
                  if lt unit_health unit_half_max_health; # attacked unit hp < 50%
                    add critChance 30;
                  end;
                  if eq side 3; #attack coming from behind
                    add critChance 35; 
                  end;

                  battle_game.randomChance critChance;
                  if eq critChance 1;  # rolled a crit
                    debug_log "Reaper crit!  to_health to_stun to_morale" to_health to_stun to_morale;
                    if gt to_health 0;
                      set bonusToHealth to_health;
                      muldiv bonusToHealth 50 100;
                      add to_health bonusToHealth;
                      add to_health 10;
                    end;
                    if gt to_stun 0;
                      set bonusToStun to_stun;
                      muldiv bonusToStun 50 100;
                      add to_stun bonusToStun;
                      add to_stun 5;
                    end;
                    if or gt bonusToStun 0 gt bonusToHealth 0;
                      set power orig_power;
                      div power 2;
                      add to_morale power;
                    end;
                    debug_log " - Damaged increased to" to_health to_stun to_morale;
                  end;

                #handle reaper TU regeneration
                  if ge to_health unit_health; # would be a kill
                    debug_log unit " - unit would be killed!";
                    set slain 1;
                  end;
                  unit.getStun stun;
                  add stun to_health;
                  add stun to_stun;
                  if ge stun unit_health;
                    debug_log unit " - unit would be stunned!";
                    set slain 1; 
                  end;

                  if gt slain 1;
                    attacker.getTimeUnitsMax addTu;
                    attacker.getTimeUnits attackerTu;
                    battle_game.randomRange roll 4 7;
                    muldiv addTu roll 100;
                    debug_log unit " - Reaper activated. roll, current TU, max, bonus:" roll attackerTu addTu;
                    add attackerTu addTu;
                    unit.setTimeUnits attackerTu;
                    debug_log unit " - Reaper bonus applied, new TU value:" attackerTu;
                  end; 
              end;
            end;
          end;
          return;

      - offset: 29   # Handle Shredder mechanic
        code: |
          var ptr RuleItem itemRuleset;
          var int weapon_state;
          var int shredder;
          var int bonus;
          var int catCheck;

          attacker.getTag shredder Tag.SHREDDER_STATE;

          if gt shredder 0;
            weapon_item.getRuleItem itemRuleset;
            itemRuleset.hasCategory catCheck "STR_HEAVY_WEAPONS";
            if eq catCheck 1;
              debug_log "Shredder activated, original to_armor / addition %:" to_armor shredder;
              set bonus to_armor;
              muldiv bonus shredder 100;
              add to_armor bonus;
              debug_log "Shredder applied, resulting to_armor damage:" to_armor;
            end;
          end;

          return;

      - offset: 30   # Handle Bulky main effect
        code: |
          var ptr RuleItem itemRuleset;
          var int state;
          var int bonus;

          unit.getTag state Tag.BULKY_STATE;

          if gt state 0;
            if gt to_stun 0;
              set bonus to_stun;
              muldiv bonus state 100;
              sub to_stun bonus;
            end;
          end;

          return;

    reactionUnitAction:
      - offset: 23   # Handle death from above main effect
        code: |
          var int unitState;
          var int actionUnitId;
          var int dfaUnitId;
          var int actionUnitState;
          var int reaction_id;

          reaction_unit.getTag unitState Tag.DEATH_FROM_ABOVE_HIT_STATE;
          if gt unitState 0;
            action_unit.getId actionUnitId;
            debug_log "actionUnitId:" actionUnitId;
            reaction_unit.getTag dfaUnitId Tag.DEATH_FROM_ABOVE_UNIT_ID;
            debug_log "dfaUnitId:" dfaUnitId;
            if eq actionUnitId dfaUnitId;
              debug_log "Units IDs matched!";
              action_unit.getTag actionUnitState Tag.DEATH_FROM_ABOVE_STATE;
              if eq actionUnitState 2;
                debug_log "Reaction distance:" distance;
                if gt distance 300;
                  debug_log "Reaction chance before DfA activation:" reaction_chance;
                  div reaction_chance 4;
                  debug_log "New reaction chance:" reaction_chance;
                end;
              end;
            end;
          end;

          return reaction_chance;

      - offset: 24   # Handle dash main effect
        code: |
          var int unitState;
          var int reactionReduction;

          reaction_unit.getTag unitState Tag.DASH_STATE;
          
          if gt unitState 0;
            debug_log "Reaction distance:" distance;
            if lt distance 50;
              debug_log "Original reaction chance:" reaction_chance;
              set reactionReduction reaction_chance;
              muldiv reactionReduction unitState 100;

              div reaction_chance 3;
              debug_log "New reaction chance:" reaction_chance;
            end;
          end;

          return reaction_chance;

    healUnit:
      - offset: 24   # Handle savior main effect
        code: |
          var int savior;
          var int health_to_heal;

          actor.getTag savior Tag.SAVIOR_STATE;

          if gt savior 0;
            if eq medikit_action_type 1; # heal
              if gt health_recovery 0;
                debug_log "Savior activated.";
                debug_log " - Health recovered (org.):" health_recovery;
                battle_game.randomRange savior 0 savior; # roll bonus heal amount
                add health_recovery savior;
                debug_log " - Health recovered (adj.):" health_recovery;
              end;
            end;
          end;

          return;

      - offset: 25   # Handle field surgeon buff
        code: |
          var int fieldSurgeon;
          var int max_health;
          var int cur_health;

          actor.getTag fieldSurgeon Tag.FIELD_SURGEON_STATE;

          if gt fieldSurgeon 0;           
            target.getHealthMax max_health;
            target.getHealth cur_health;
            if and eq medikit_action_type 1 gt max_health cur_health; # heal
              debug_log target "was healed by field surgeon.";
              target.setTag Tag.HEALED_BY_FIELD_SURGEON fieldSurgeon;
            end;
          end;

          return;

    returnFromMissionUnit:
      - offset: 23   # Handle field surgeon main effect
        code: |
          var int healed_by_field_surgeon;
          var int factor;
          var int max_health;
          var int recover_min;
          var int recover_max;

          unit.getTag healed_by_field_surgeon Tag.HEALED_BY_FIELD_SURGEON;

          if gt healed_by_field_surgeon 0;
            unit.getHealthMax max_health;
            debug_log unit " is under Field Surgeon effect. Recovery time changed from" recovery_time;
            set factor 100;
            sub factor healed_by_field_surgeon;
            muldiv recovery_time factor 100;
            debug_log unit " - to" recovery_time;
          end;

          return;

    recolorUnitSprite:
      - offset: 0.1 #Handles periodic recolors due to daze
        code: |
          var int frame;
          var int frameLength;
          var int dazeTag;
          var int recolorPeriod;
          var int desync;
          var int color;
          var int newShade;
          var int temp;
          var ptr RuleArmor armorRuleset;

          # Check to make sure this unit isn't set to be recolored by a hit first
          unit.getTag frame Tag.LAST_HIT_FRAME;
          set frameLength 6;
          set recolorPeriod 36;
 
          if neq frame 0;
            set temp anim_frame;
            sub temp frame;

            if lt temp frameLength;
              return new_pixel;
            end;

          end;

          unit.getTag desync Tag.UNIT_RECOLOR_DESYNC;
          set frame anim_frame;
          add frame desync;
          mod frame recolorPeriod;

          unit.getTag temp Tag.FTAG_ISDAZED;

          if and neq temp 0 lt frame frameLength;
            #set temp anim_frame;
            wavegen_tri frame 12 12 12;
            mul frame -1;
            add frame 6; #8;
            get_shade newShade new_pixel;
            sub newShade frame;

            if gt newShade 4;
              set_shade new_pixel newShade;
              else;
              set_shade new_pixel 4;
            end;


          end;

          return new_pixel;

      #*** Handles periodic recolors due to energy or psi shields on units ***
      - offset: 1
        code: |
          var int frame;
          var int frameLength;
          var int recolorPeriod;
          var int desync;
          var int color;
          var int newShade;
          var int temp;
          var int psiShield;
          var int mana;
          var ptr RuleArmor armorRuleset;

          # Check to make sure this unit isn't set to be recolored by a hit first
          unit.getTag frame Tag.UNIT_RECOLOR_START_FRAME;
          unit.getTag frameLength Tag.UNIT_RECOLOR_FRAME_LENGTH;

          if neq frame 0;

            set temp anim_frame;
            sub temp frame;

            if lt temp frameLength;

              return new_pixel;

            end;

          end;

          set recolorPeriod 32;
          set frameLength 4;

          unit.getTag desync Tag.UNIT_RECOLOR_DESYNC;
          set frame anim_frame;
          add frame desync;
          mod frame recolorPeriod;

          # First, a blue flash if the unit has an energy shield
          unit.getTag temp Tag.UNIT_ENERGY_SHIELD_HP;

          if eq temp 0;
            unit.getTag psiShield Tag.UNIT_PSI_SHIELD_TYPE;
            if gt psiShield 0;
              unit.getMana mana;
              set temp mana;
            end;
          end;

          if and neq temp 0 lt frame frameLength;

            unit.getRuleArmor armorRuleset;
            armorRuleset.getTag color Tag.ARMOR_ENERGY_SHIELD_FLASH_COLOR;

            if and eq color 0 gt psiShield 0;
              unit.getTag color Tag.UNIT_RECOLOR_COLOR;
            end;

            if eq color 0;

              set color COLOR_X1_BLUE1;

            end;

            set temp frameLength;
            sub temp frame;
            mul temp 2; # a parameter that creates a nice flash animation
            get_shade newShade new_pixel;
            sub newShade temp;

            if and gt newShade 3 lt newShade 16;

              set_shade new_pixel newShade;
              set_color new_pixel color;

            end;

          end;

          return new_pixel;

      - offset: 10
        code: |
          var int frame;
          var int frameLength;
          var int color;
          var int newShade;
          var int temp;

          unit.getTag frame Tag.UNIT_RECOLOR_START_FRAME;
          unit.getTag frameLength Tag.UNIT_RECOLOR_FRAME_LENGTH;

          if neq frame 0;
            set temp anim_frame;
            sub temp frame;

            if lt temp frameLength;
              # Check shade, add some darkening decay, but don't recolor if it'd go too dark
              get_shade newShade new_pixel;
              mul temp 4;
              sub newShade temp;
              if or lt newShade 4 gt newShade 15;
                return new_pixel;
              end;

              unit.getTag color Tag.UNIT_RECOLOR_COLOR;
              set_color new_pixel color;
              set_shade new_pixel newShade;
            end;
          end;

          return new_pixel;

    recolorItemSprite:
      - offset: 10
        code: |
          var ptr RuleItem shieldItem;
          var int shieldCapacity;
          var int shieldNeedsPriming;
          var int shieldTimer;
          var int shieldHp;
          var int shieldPercent;
          var int shieldIsPrimed;
          var int color;
          var int colorToReplace;
          var int shadeIndex;
          var int temp;

          item.getRuleItem shieldItem;
          shieldItem.getTag shieldCapacity Tag.ITEM_ENERGY_SHIELD_CAPACITY;

          if eq shieldCapacity 0;
            return new_pixel;
          end;

          item.getTag shieldHp Tag.ITEM_ENERGY_SHIELD_HP;
          set shieldPercent shieldHp;
          muldiv shieldPercent 100 shieldCapacity;

          # Recolor behavior is based on shield type
          shieldItem.getTag shieldNeedsPriming Tag.ITEM_ENERGY_SHIELD_NEEDS_PRIMING;

          item.getFuseTimer shieldTimer;
          if and neq shieldNeedsPriming 0 gt shieldTimer 0; # Get shield percent for consumable shields
            item.getTag shieldIsPrimed Tag.ITEM_ENERGY_SHIELD_IS_PRIMED;

            if eq shieldIsPrimed 0; # Haven't been hit yet, but should show shield
              set shieldPercent 100;
            end;
          end;

          # Choose color to replace on sprite
          get_color color new_pixel;
          set temp 0;

          # Pick the color to replace from the ruleset tags
          shieldItem.getTag colorToReplace Tag.ITEM_ENERGY_SHIELD_COLOR_REPLACED_BY_INDICATOR;

          if eq color colorToReplace;
            get_shade shadeIndex new_pixel;

            shieldItem.getTag temp Tag.ITEM_ENERGY_SHIELD_INDICATOR_COLOR;

            if eq shieldPercent 0; # Choose critical shields at 20%, make tag later?
              if and neq shieldNeedsPriming 0 gt shieldTimer 0;
                shieldItem.getTag temp Tag.ITEM_ENERGY_SHIELD_DOWN_COLOR;
              else eq shieldNeedsPriming 0;
                shieldItem.getTag temp Tag.ITEM_ENERGY_SHIELD_DOWN_COLOR;
              end;
            end;

            if eq temp 0; # Default color to blue if none is found
              set temp COLOR_X1_BLUE1;
            end;

            set color temp;

            set temp shieldPercent;
            sub temp 100;
            abs temp;
            muldiv temp 15 100;
            add shadeIndex temp;
            limit shadeIndex 0 15;
            set_color new_pixel color;
            set_shade new_pixel shadeIndex;
          end;

          return new_pixel;        

    applySoldierBonuses:
      - offset: 23
        code: |
          var int id;
          var int has_aim;
          var int centerMass;
          var int has_death_from_above;
          var int has_shredder;
          var int has_steady_grip;
          var int has_bulky;
          var int has_ever_vigilant;
          var int has_rapid_targeting;
          var int has_reaper;
          var int has_dash;
          var int has_unifight;
          var int has_field_surgeon;
          var int has_savior;
          var int has_utility_spec;
          var int has_unarmed;

          unit.getId id;

          soldier_bonus.getTag has_aim Tag.AIM;
          soldier_bonus.getTag centerMass Tag.CENTER_MASS;
          soldier_bonus.getTag has_death_from_above Tag.DEATH_FROM_ABOVE;

          soldier_bonus.getTag has_shredder Tag.SHREDDER;
          soldier_bonus.getTag has_steady_grip Tag.STEADY_GRIP;
          soldier_bonus.getTag has_bulky Tag.BULKY;

          soldier_bonus.getTag has_ever_vigilant Tag.EVER_VIGILANT;
          soldier_bonus.getTag has_rapid_targeting Tag.RAPID_TARGETING;

          soldier_bonus.getTag has_reaper Tag.REAPER;
          soldier_bonus.getTag has_dash Tag.DASH;
          soldier_bonus.getTag has_unifight Tag.UNIFIGHT;

          soldier_bonus.getTag has_field_surgeon Tag.FIELD_SURGEON;
          soldier_bonus.getTag has_savior Tag.SAVIOR;
          soldier_bonus.getTag has_utility_spec Tag.UTILITY_SPECIALIST;

          soldier_bonus.getTag has_unarmed Tag.STR_UNARMED_FIGHTER;

          if gt has_aim 0;
            debug_log "Unit" id "- Aim perk found!";
            unit.setTag Tag.AIM_STATE 1;
          end;
          if gt centerMass 0;
            debug_log "Unit" id "- Center Mass perk: " centerMass;
            unit.setTag Tag.CENTER_MASS_STATE centerMass;
          end;
          if gt has_death_from_above 0;
            debug_log "Unit" id "- Death from above perk!";
            unit.setTag Tag.DEATH_FROM_ABOVE_STATE 1;
          end;

          if gt has_shredder 0;
            debug_log "Unit" id "- Shredder perk: " has_shredder;
            unit.setTag Tag.SHREDDER_STATE has_shredder;
          end;
          if gt has_steady_grip 0;
            debug_log "Unit" id "- Steady grip perk: " has_steady_grip;
            unit.setTag Tag.STEADY_GRIP_STATE has_steady_grip;
          end;
          if gt has_bulky 0;
            debug_log "Unit" id "- Bulky perk: " has_bulky;
            unit.setTag Tag.BULKY_STATE has_bulky;
          end;

          if gt has_ever_vigilant 0;
            debug_log "Unit" id "- Ever vigilant perk found!";
            unit.setTag Tag.EVER_VIGILANT_STATE 1;
          end;
          if gt has_rapid_targeting 0;
            debug_log "Unit" id "- Rapid targeting perk: " has_rapid_targeting;
            unit.setTag Tag.RAPID_TARGETING_STATE has_rapid_targeting;
          end;

          if gt has_reaper 0;
            debug_log "Unit" id "- Reaper perk found!" has_reaper;
            unit.setTag Tag.REAPER_STATE 1;
          end;
          if gt has_dash 0;
            debug_log "Unit" id "- Dash perk: " has_dash;
            unit.setTag Tag.DASH_STATE has_dash;
          end;
          if gt has_unifight 0;
            debug_log "Unit" id "- Unifight perk: " has_unifight;
            unit.setTag Tag.UNIFIGHT_STATE has_unifight;
          end;

          if gt has_field_surgeon 0;
            debug_log "Unit" id "- Field Surgeon perk: " has_field_surgeon;
            unit.setTag Tag.FIELD_SURGEON_STATE has_field_surgeon;
          end;
          if gt has_savior 0;
            debug_log "Unit" id "- Saviour perk: " has_savior;
            unit.setTag Tag.SAVIOR_STATE has_savior;
          end;
          if gt has_utility_spec 0;
            debug_log "Unit" id "- Utility Specialist perk: " has_utility_spec;
            unit.setTag Tag.UTILITY_SPECIALIST_STATE 1;
          end;

          if gt has_unarmed 0;
          debug_log "Unit" id "- Unarmed fighter perk: " has_unarmed;
            unit.setTag Tag.STR_UNARMED_FIGHTER_STATE has_unarmed;
          end;

          return;

    detectUfoFromBase:
      - offset: 1   # handle small ufo increased detection
        code: |
          var ptr RuleUfo rule;
          var int change;

          ufo.getRuleUfo rule;
          rule.getTag change Tag.UFO_DETECTION_CHANGE ;
          if neq change 0;
            debug_log "UFO detecting with addtional chance: " ufo change;
            debug_log "original detection chance: " detection_chance;
            add detection_chance change;
            debug_log "new detection chance: " detection_chance;
          end;
          return detection_type detection_chance;



# extended:
#   tags:
#     RuleItem:
#       ITEM_NV_GOGGLES: int
#     BattleUnitVisibility:
#       VISIBILITY_NV_GOGGLES: int
#   scripts:
#     visibilityUnit:
#       - offset: 3
#         code: |
#           var int itemA;
#           var int itemB;
#           var int targetShade;
#           var ptr BattleItem item;
#           var ptr RuleItem type;
          
#           #get info about left hand item
#           observer_unit.getLeftHandWeapon item;
#           item.getRuleItem type;
#           type.getTag itemA Tag.ITEM_NV_GOGGLES;
            
#           #get info about left hand item
#           observer_unit.getRightHandWeapon item;
#           item.getRuleItem type;
#           type.getTag itemB Tag.ITEM_NV_GOGGLES;
#           if eq visibility_mode null; #default visibility
            
#             #if left or rigth item have NV bonus
#             if or eq itemA 1 eq itemB 1;
#               target_unit.getTileShade targetShade;
#               if gt targetShade 9;
#                 add current_visibility 48; #16*3 = 3 tiles better visibility in dark
#                 set visibility_mode Tag.VISIBILITY_NV_GOGGLES; #toggle to NV mode
#               end;
#             end;
#           else eq visibility_mode Tag.VISIBILITY_NV_GOGGLES; #assume that other script already set "NV" mode, we only add small bonus in that case
#             if or eq itemA 1 eq itemB 1;
#               add current_visibility 16;
#             end;
#           end;
          
#           return current_visibility visibility_mode;